/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */

import {
  ethers,
  EventFilter,
  Signer,
  BigNumber,
  BigNumberish,
  PopulatedTransaction,
} from "ethers";
import {
  Contract,
  ContractTransaction,
  Overrides,
  PayableOverrides,
  CallOverrides,
} from "@ethersproject/contracts";
import { BytesLike } from "@ethersproject/bytes";
import { Listener, Provider } from "@ethersproject/providers";
import { FunctionFragment, EventFragment, Result } from "@ethersproject/abi";

interface RollaOrderProtocolInterface extends ethers.utils.Interface {
  functions: {
    "CHAIN_TOKEN_ADDRESS()": FunctionFragment;
    "DOMAIN_SEPARATOR()": FunctionFragment;
    "EIP712_DOMAIN_TYPEHASH()": FunctionFragment;
    "META_ORDER_PROTOCOL_TYPEHASH()": FunctionFragment;
    "OPTION_ATTRIBUTES_TYPEHASH()": FunctionFragment;
    "ORDER_TRACKING_TYPEHASH()": FunctionFragment;
    "ROLLA_ORDER_PROTOCOL_TYPEHASH()": FunctionFragment;
    "SIGNATURE_TYPEHASH()": FunctionFragment;
    "acceptOwnership()": FunctionFragment;
    "cancelOrder(tuple)": FunctionFragment;
    "cancelOrdersUpTo(uint64)": FunctionFragment;
    "chainTokenWrapper()": FunctionFragment;
    "collateralToken()": FunctionFragment;
    "controller()": FunctionFragment;
    "executeMetaTransaction(tuple,bytes32,bytes32,uint8,uint8)": FunctionFragment;
    "fillOrder(tuple,tuple)": FunctionFragment;
    "fillOrderWithChainToken(tuple,tuple)": FunctionFragment;
    "fillOrderWithPermit(tuple,tuple,bytes)": FunctionFragment;
    "getNonce(address)": FunctionFragment;
    "hashMetaOrder(tuple)": FunctionFragment;
    "hashOrder(tuple)": FunctionFragment;
    "isInvalidatedOrder(bytes32)": FunctionFragment;
    "makerCancelTime(address)": FunctionFragment;
    "name()": FunctionFragment;
    "onERC1155Received(address,address,uint256,uint256,bytes)": FunctionFragment;
    "optionsFactory()": FunctionFragment;
    "owner()": FunctionFragment;
    "pendingOwner()": FunctionFragment;
    "protocolFee()": FunctionFragment;
    "renounceOwnership()": FunctionFragment;
    "sendFees(address,address,uint256)": FunctionFragment;
    "setProtocolFee(uint256)": FunctionFragment;
    "transferOwnership(address)": FunctionFragment;
    "version()": FunctionFragment;
  };

  encodeFunctionData(
    functionFragment: "CHAIN_TOKEN_ADDRESS",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "DOMAIN_SEPARATOR",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "EIP712_DOMAIN_TYPEHASH",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "META_ORDER_PROTOCOL_TYPEHASH",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "OPTION_ATTRIBUTES_TYPEHASH",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "ORDER_TRACKING_TYPEHASH",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "ROLLA_ORDER_PROTOCOL_TYPEHASH",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "SIGNATURE_TYPEHASH",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "acceptOwnership",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "cancelOrder",
    values: [
      {
        orderCreationTimestamp: BigNumberish;
        orderExpirationTimestamp: BigNumberish;
        makerAsset: string;
        optionAttributes: {
          underlyingAsset: string;
          oracle: string;
          expiryTime: BigNumberish;
          isCall: boolean;
          strikePrice: BigNumberish;
        };
        maker: string;
        taker: string;
        allowedSender: string;
        makingAmount: BigNumberish;
        takingAmount: BigNumberish;
        whitelist: string;
        orderTracking: {
          integrator: string;
          integratorPercentage: BigNumberish;
          orderTag: BytesLike;
        };
        takerIsSigner: boolean;
      }
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "cancelOrdersUpTo",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "chainTokenWrapper",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "collateralToken",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "controller",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "executeMetaTransaction",
    values: [
      {
        functionType: BigNumberish;
        nonce: BigNumberish;
        deadline: BigNumberish;
        from: string;
        order: {
          orderCreationTimestamp: BigNumberish;
          orderExpirationTimestamp: BigNumberish;
          makerAsset: string;
          optionAttributes: {
            underlyingAsset: string;
            oracle: string;
            expiryTime: BigNumberish;
            isCall: boolean;
            strikePrice: BigNumberish;
          };
          maker: string;
          taker: string;
          allowedSender: string;
          makingAmount: BigNumberish;
          takingAmount: BigNumberish;
          whitelist: string;
          orderTracking: {
            integrator: string;
            integratorPercentage: BigNumberish;
            orderTag: BytesLike;
          };
          takerIsSigner: boolean;
        };
        signature: { signatureType: BigNumberish; signatureData: BytesLike };
        permit: BytesLike;
      },
      BytesLike,
      BytesLike,
      BigNumberish,
      BigNumberish
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "fillOrder",
    values: [
      {
        orderCreationTimestamp: BigNumberish;
        orderExpirationTimestamp: BigNumberish;
        makerAsset: string;
        optionAttributes: {
          underlyingAsset: string;
          oracle: string;
          expiryTime: BigNumberish;
          isCall: boolean;
          strikePrice: BigNumberish;
        };
        maker: string;
        taker: string;
        allowedSender: string;
        makingAmount: BigNumberish;
        takingAmount: BigNumberish;
        whitelist: string;
        orderTracking: {
          integrator: string;
          integratorPercentage: BigNumberish;
          orderTag: BytesLike;
        };
        takerIsSigner: boolean;
      },
      { signatureType: BigNumberish; signatureData: BytesLike }
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "fillOrderWithChainToken",
    values: [
      {
        orderCreationTimestamp: BigNumberish;
        orderExpirationTimestamp: BigNumberish;
        makerAsset: string;
        optionAttributes: {
          underlyingAsset: string;
          oracle: string;
          expiryTime: BigNumberish;
          isCall: boolean;
          strikePrice: BigNumberish;
        };
        maker: string;
        taker: string;
        allowedSender: string;
        makingAmount: BigNumberish;
        takingAmount: BigNumberish;
        whitelist: string;
        orderTracking: {
          integrator: string;
          integratorPercentage: BigNumberish;
          orderTag: BytesLike;
        };
        takerIsSigner: boolean;
      },
      { signatureType: BigNumberish; signatureData: BytesLike }
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "fillOrderWithPermit",
    values: [
      {
        orderCreationTimestamp: BigNumberish;
        orderExpirationTimestamp: BigNumberish;
        makerAsset: string;
        optionAttributes: {
          underlyingAsset: string;
          oracle: string;
          expiryTime: BigNumberish;
          isCall: boolean;
          strikePrice: BigNumberish;
        };
        maker: string;
        taker: string;
        allowedSender: string;
        makingAmount: BigNumberish;
        takingAmount: BigNumberish;
        whitelist: string;
        orderTracking: {
          integrator: string;
          integratorPercentage: BigNumberish;
          orderTag: BytesLike;
        };
        takerIsSigner: boolean;
      },
      { signatureType: BigNumberish; signatureData: BytesLike },
      BytesLike
    ]
  ): string;
  encodeFunctionData(functionFragment: "getNonce", values: [string]): string;
  encodeFunctionData(
    functionFragment: "hashMetaOrder",
    values: [
      {
        functionType: BigNumberish;
        nonce: BigNumberish;
        deadline: BigNumberish;
        from: string;
        order: {
          orderCreationTimestamp: BigNumberish;
          orderExpirationTimestamp: BigNumberish;
          makerAsset: string;
          optionAttributes: {
            underlyingAsset: string;
            oracle: string;
            expiryTime: BigNumberish;
            isCall: boolean;
            strikePrice: BigNumberish;
          };
          maker: string;
          taker: string;
          allowedSender: string;
          makingAmount: BigNumberish;
          takingAmount: BigNumberish;
          whitelist: string;
          orderTracking: {
            integrator: string;
            integratorPercentage: BigNumberish;
            orderTag: BytesLike;
          };
          takerIsSigner: boolean;
        };
        signature: { signatureType: BigNumberish; signatureData: BytesLike };
        permit: BytesLike;
      }
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "hashOrder",
    values: [
      {
        orderCreationTimestamp: BigNumberish;
        orderExpirationTimestamp: BigNumberish;
        makerAsset: string;
        optionAttributes: {
          underlyingAsset: string;
          oracle: string;
          expiryTime: BigNumberish;
          isCall: boolean;
          strikePrice: BigNumberish;
        };
        maker: string;
        taker: string;
        allowedSender: string;
        makingAmount: BigNumberish;
        takingAmount: BigNumberish;
        whitelist: string;
        orderTracking: {
          integrator: string;
          integratorPercentage: BigNumberish;
          orderTag: BytesLike;
        };
        takerIsSigner: boolean;
      }
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "isInvalidatedOrder",
    values: [BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "makerCancelTime",
    values: [string]
  ): string;
  encodeFunctionData(functionFragment: "name", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "onERC1155Received",
    values: [string, string, BigNumberish, BigNumberish, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "optionsFactory",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "owner", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "pendingOwner",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "protocolFee",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "renounceOwnership",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "sendFees",
    values: [string, string, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "setProtocolFee",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "transferOwnership",
    values: [string]
  ): string;
  encodeFunctionData(functionFragment: "version", values?: undefined): string;

  decodeFunctionResult(
    functionFragment: "CHAIN_TOKEN_ADDRESS",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "DOMAIN_SEPARATOR",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "EIP712_DOMAIN_TYPEHASH",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "META_ORDER_PROTOCOL_TYPEHASH",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "OPTION_ATTRIBUTES_TYPEHASH",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "ORDER_TRACKING_TYPEHASH",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "ROLLA_ORDER_PROTOCOL_TYPEHASH",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "SIGNATURE_TYPEHASH",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "acceptOwnership",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "cancelOrder",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "cancelOrdersUpTo",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "chainTokenWrapper",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "collateralToken",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "controller", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "executeMetaTransaction",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "fillOrder", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "fillOrderWithChainToken",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "fillOrderWithPermit",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "getNonce", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "hashMetaOrder",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "hashOrder", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "isInvalidatedOrder",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "makerCancelTime",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "name", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "onERC1155Received",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "optionsFactory",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "owner", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "pendingOwner",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "protocolFee",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "renounceOwnership",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "sendFees", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "setProtocolFee",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "transferOwnership",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "version", data: BytesLike): Result;

  events: {
    "FeesSent(address,address,uint256)": EventFragment;
    "MetaTransactionExecuted(address,address,uint256)": EventFragment;
    "OrderCancelled(bytes32,address)": EventFragment;
    "OrderFilled(bytes32,tuple,uint256,uint256,address,bytes32,uint256,uint256,uint256,uint256)": EventFragment;
    "OrdersCancelledUpTo(uint64,address)": EventFragment;
    "OwnershipTransferCompleted(address,address)": EventFragment;
    "OwnershipTransferStarted(address,address)": EventFragment;
    "ProtocolFeeChanged(uint256,uint256)": EventFragment;
  };

  getEvent(nameOrSignatureOrTopic: "FeesSent"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "MetaTransactionExecuted"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "OrderCancelled"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "OrderFilled"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "OrdersCancelledUpTo"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "OwnershipTransferCompleted"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "OwnershipTransferStarted"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "ProtocolFeeChanged"): EventFragment;
}

export class RollaOrderProtocol extends Contract {
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  on(event: EventFilter | string, listener: Listener): this;
  once(event: EventFilter | string, listener: Listener): this;
  addListener(eventName: EventFilter | string, listener: Listener): this;
  removeAllListeners(eventName: EventFilter | string): this;
  removeListener(eventName: any, listener: Listener): this;

  interface: RollaOrderProtocolInterface;

  functions: {
    CHAIN_TOKEN_ADDRESS(overrides?: CallOverrides): Promise<[string]>;

    "CHAIN_TOKEN_ADDRESS()"(overrides?: CallOverrides): Promise<[string]>;

    DOMAIN_SEPARATOR(overrides?: CallOverrides): Promise<[string]>;

    "DOMAIN_SEPARATOR()"(overrides?: CallOverrides): Promise<[string]>;

    EIP712_DOMAIN_TYPEHASH(overrides?: CallOverrides): Promise<[string]>;

    "EIP712_DOMAIN_TYPEHASH()"(overrides?: CallOverrides): Promise<[string]>;

    META_ORDER_PROTOCOL_TYPEHASH(overrides?: CallOverrides): Promise<[string]>;

    "META_ORDER_PROTOCOL_TYPEHASH()"(
      overrides?: CallOverrides
    ): Promise<[string]>;

    OPTION_ATTRIBUTES_TYPEHASH(overrides?: CallOverrides): Promise<[string]>;

    "OPTION_ATTRIBUTES_TYPEHASH()"(
      overrides?: CallOverrides
    ): Promise<[string]>;

    ORDER_TRACKING_TYPEHASH(overrides?: CallOverrides): Promise<[string]>;

    "ORDER_TRACKING_TYPEHASH()"(overrides?: CallOverrides): Promise<[string]>;

    ROLLA_ORDER_PROTOCOL_TYPEHASH(overrides?: CallOverrides): Promise<[string]>;

    "ROLLA_ORDER_PROTOCOL_TYPEHASH()"(
      overrides?: CallOverrides
    ): Promise<[string]>;

    SIGNATURE_TYPEHASH(overrides?: CallOverrides): Promise<[string]>;

    "SIGNATURE_TYPEHASH()"(overrides?: CallOverrides): Promise<[string]>;

    acceptOwnership(overrides?: Overrides): Promise<ContractTransaction>;

    "acceptOwnership()"(overrides?: Overrides): Promise<ContractTransaction>;

    cancelOrder(
      order: {
        orderCreationTimestamp: BigNumberish;
        orderExpirationTimestamp: BigNumberish;
        makerAsset: string;
        optionAttributes: {
          underlyingAsset: string;
          oracle: string;
          expiryTime: BigNumberish;
          isCall: boolean;
          strikePrice: BigNumberish;
        };
        maker: string;
        taker: string;
        allowedSender: string;
        makingAmount: BigNumberish;
        takingAmount: BigNumberish;
        whitelist: string;
        orderTracking: {
          integrator: string;
          integratorPercentage: BigNumberish;
          orderTag: BytesLike;
        };
        takerIsSigner: boolean;
      },
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    "cancelOrder((uint64,uint64,address,(address,address,uint88,bool,uint256),address,address,address,uint256,uint256,address,(address,uint256,bytes32),bool))"(
      order: {
        orderCreationTimestamp: BigNumberish;
        orderExpirationTimestamp: BigNumberish;
        makerAsset: string;
        optionAttributes: {
          underlyingAsset: string;
          oracle: string;
          expiryTime: BigNumberish;
          isCall: boolean;
          strikePrice: BigNumberish;
        };
        maker: string;
        taker: string;
        allowedSender: string;
        makingAmount: BigNumberish;
        takingAmount: BigNumberish;
        whitelist: string;
        orderTracking: {
          integrator: string;
          integratorPercentage: BigNumberish;
          orderTag: BytesLike;
        };
        takerIsSigner: boolean;
      },
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    cancelOrdersUpTo(
      timestamp: BigNumberish,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    "cancelOrdersUpTo(uint64)"(
      timestamp: BigNumberish,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    chainTokenWrapper(overrides?: CallOverrides): Promise<[string]>;

    "chainTokenWrapper()"(overrides?: CallOverrides): Promise<[string]>;

    collateralToken(overrides?: CallOverrides): Promise<[string]>;

    "collateralToken()"(overrides?: CallOverrides): Promise<[string]>;

    controller(overrides?: CallOverrides): Promise<[string]>;

    "controller()"(overrides?: CallOverrides): Promise<[string]>;

    executeMetaTransaction(
      metaOrder: {
        functionType: BigNumberish;
        nonce: BigNumberish;
        deadline: BigNumberish;
        from: string;
        order: {
          orderCreationTimestamp: BigNumberish;
          orderExpirationTimestamp: BigNumberish;
          makerAsset: string;
          optionAttributes: {
            underlyingAsset: string;
            oracle: string;
            expiryTime: BigNumberish;
            isCall: boolean;
            strikePrice: BigNumberish;
          };
          maker: string;
          taker: string;
          allowedSender: string;
          makingAmount: BigNumberish;
          takingAmount: BigNumberish;
          whitelist: string;
          orderTracking: {
            integrator: string;
            integratorPercentage: BigNumberish;
            orderTag: BytesLike;
          };
          takerIsSigner: boolean;
        };
        signature: { signatureType: BigNumberish; signatureData: BytesLike };
        permit: BytesLike;
      },
      r: BytesLike,
      s: BytesLike,
      v: BigNumberish,
      signatureType: BigNumberish,
      overrides?: PayableOverrides
    ): Promise<ContractTransaction>;

    "executeMetaTransaction((uint8,uint256,uint256,address,(uint64,uint64,address,(address,address,uint88,bool,uint256),address,address,address,uint256,uint256,address,(address,uint256,bytes32),bool),(uint8,bytes),bytes),bytes32,bytes32,uint8,uint8)"(
      metaOrder: {
        functionType: BigNumberish;
        nonce: BigNumberish;
        deadline: BigNumberish;
        from: string;
        order: {
          orderCreationTimestamp: BigNumberish;
          orderExpirationTimestamp: BigNumberish;
          makerAsset: string;
          optionAttributes: {
            underlyingAsset: string;
            oracle: string;
            expiryTime: BigNumberish;
            isCall: boolean;
            strikePrice: BigNumberish;
          };
          maker: string;
          taker: string;
          allowedSender: string;
          makingAmount: BigNumberish;
          takingAmount: BigNumberish;
          whitelist: string;
          orderTracking: {
            integrator: string;
            integratorPercentage: BigNumberish;
            orderTag: BytesLike;
          };
          takerIsSigner: boolean;
        };
        signature: { signatureType: BigNumberish; signatureData: BytesLike };
        permit: BytesLike;
      },
      r: BytesLike,
      s: BytesLike,
      v: BigNumberish,
      signatureType: BigNumberish,
      overrides?: PayableOverrides
    ): Promise<ContractTransaction>;

    fillOrder(
      order: {
        orderCreationTimestamp: BigNumberish;
        orderExpirationTimestamp: BigNumberish;
        makerAsset: string;
        optionAttributes: {
          underlyingAsset: string;
          oracle: string;
          expiryTime: BigNumberish;
          isCall: boolean;
          strikePrice: BigNumberish;
        };
        maker: string;
        taker: string;
        allowedSender: string;
        makingAmount: BigNumberish;
        takingAmount: BigNumberish;
        whitelist: string;
        orderTracking: {
          integrator: string;
          integratorPercentage: BigNumberish;
          orderTag: BytesLike;
        };
        takerIsSigner: boolean;
      },
      signature: { signatureType: BigNumberish; signatureData: BytesLike },
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    "fillOrder((uint64,uint64,address,(address,address,uint88,bool,uint256),address,address,address,uint256,uint256,address,(address,uint256,bytes32),bool),(uint8,bytes))"(
      order: {
        orderCreationTimestamp: BigNumberish;
        orderExpirationTimestamp: BigNumberish;
        makerAsset: string;
        optionAttributes: {
          underlyingAsset: string;
          oracle: string;
          expiryTime: BigNumberish;
          isCall: boolean;
          strikePrice: BigNumberish;
        };
        maker: string;
        taker: string;
        allowedSender: string;
        makingAmount: BigNumberish;
        takingAmount: BigNumberish;
        whitelist: string;
        orderTracking: {
          integrator: string;
          integratorPercentage: BigNumberish;
          orderTag: BytesLike;
        };
        takerIsSigner: boolean;
      },
      signature: { signatureType: BigNumberish; signatureData: BytesLike },
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    fillOrderWithChainToken(
      order: {
        orderCreationTimestamp: BigNumberish;
        orderExpirationTimestamp: BigNumberish;
        makerAsset: string;
        optionAttributes: {
          underlyingAsset: string;
          oracle: string;
          expiryTime: BigNumberish;
          isCall: boolean;
          strikePrice: BigNumberish;
        };
        maker: string;
        taker: string;
        allowedSender: string;
        makingAmount: BigNumberish;
        takingAmount: BigNumberish;
        whitelist: string;
        orderTracking: {
          integrator: string;
          integratorPercentage: BigNumberish;
          orderTag: BytesLike;
        };
        takerIsSigner: boolean;
      },
      signature: { signatureType: BigNumberish; signatureData: BytesLike },
      overrides?: PayableOverrides
    ): Promise<ContractTransaction>;

    "fillOrderWithChainToken((uint64,uint64,address,(address,address,uint88,bool,uint256),address,address,address,uint256,uint256,address,(address,uint256,bytes32),bool),(uint8,bytes))"(
      order: {
        orderCreationTimestamp: BigNumberish;
        orderExpirationTimestamp: BigNumberish;
        makerAsset: string;
        optionAttributes: {
          underlyingAsset: string;
          oracle: string;
          expiryTime: BigNumberish;
          isCall: boolean;
          strikePrice: BigNumberish;
        };
        maker: string;
        taker: string;
        allowedSender: string;
        makingAmount: BigNumberish;
        takingAmount: BigNumberish;
        whitelist: string;
        orderTracking: {
          integrator: string;
          integratorPercentage: BigNumberish;
          orderTag: BytesLike;
        };
        takerIsSigner: boolean;
      },
      signature: { signatureType: BigNumberish; signatureData: BytesLike },
      overrides?: PayableOverrides
    ): Promise<ContractTransaction>;

    fillOrderWithPermit(
      order: {
        orderCreationTimestamp: BigNumberish;
        orderExpirationTimestamp: BigNumberish;
        makerAsset: string;
        optionAttributes: {
          underlyingAsset: string;
          oracle: string;
          expiryTime: BigNumberish;
          isCall: boolean;
          strikePrice: BigNumberish;
        };
        maker: string;
        taker: string;
        allowedSender: string;
        makingAmount: BigNumberish;
        takingAmount: BigNumberish;
        whitelist: string;
        orderTracking: {
          integrator: string;
          integratorPercentage: BigNumberish;
          orderTag: BytesLike;
        };
        takerIsSigner: boolean;
      },
      signature: { signatureType: BigNumberish; signatureData: BytesLike },
      permit: BytesLike,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    "fillOrderWithPermit((uint64,uint64,address,(address,address,uint88,bool,uint256),address,address,address,uint256,uint256,address,(address,uint256,bytes32),bool),(uint8,bytes),bytes)"(
      order: {
        orderCreationTimestamp: BigNumberish;
        orderExpirationTimestamp: BigNumberish;
        makerAsset: string;
        optionAttributes: {
          underlyingAsset: string;
          oracle: string;
          expiryTime: BigNumberish;
          isCall: boolean;
          strikePrice: BigNumberish;
        };
        maker: string;
        taker: string;
        allowedSender: string;
        makingAmount: BigNumberish;
        takingAmount: BigNumberish;
        whitelist: string;
        orderTracking: {
          integrator: string;
          integratorPercentage: BigNumberish;
          orderTag: BytesLike;
        };
        takerIsSigner: boolean;
      },
      signature: { signatureType: BigNumberish; signatureData: BytesLike },
      permit: BytesLike,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    getNonce(user: string, overrides?: CallOverrides): Promise<[BigNumber]>;

    "getNonce(address)"(
      user: string,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    hashMetaOrder(
      metaOrder: {
        functionType: BigNumberish;
        nonce: BigNumberish;
        deadline: BigNumberish;
        from: string;
        order: {
          orderCreationTimestamp: BigNumberish;
          orderExpirationTimestamp: BigNumberish;
          makerAsset: string;
          optionAttributes: {
            underlyingAsset: string;
            oracle: string;
            expiryTime: BigNumberish;
            isCall: boolean;
            strikePrice: BigNumberish;
          };
          maker: string;
          taker: string;
          allowedSender: string;
          makingAmount: BigNumberish;
          takingAmount: BigNumberish;
          whitelist: string;
          orderTracking: {
            integrator: string;
            integratorPercentage: BigNumberish;
            orderTag: BytesLike;
          };
          takerIsSigner: boolean;
        };
        signature: { signatureType: BigNumberish; signatureData: BytesLike };
        permit: BytesLike;
      },
      overrides?: CallOverrides
    ): Promise<[string]>;

    "hashMetaOrder((uint8,uint256,uint256,address,(uint64,uint64,address,(address,address,uint88,bool,uint256),address,address,address,uint256,uint256,address,(address,uint256,bytes32),bool),(uint8,bytes),bytes))"(
      metaOrder: {
        functionType: BigNumberish;
        nonce: BigNumberish;
        deadline: BigNumberish;
        from: string;
        order: {
          orderCreationTimestamp: BigNumberish;
          orderExpirationTimestamp: BigNumberish;
          makerAsset: string;
          optionAttributes: {
            underlyingAsset: string;
            oracle: string;
            expiryTime: BigNumberish;
            isCall: boolean;
            strikePrice: BigNumberish;
          };
          maker: string;
          taker: string;
          allowedSender: string;
          makingAmount: BigNumberish;
          takingAmount: BigNumberish;
          whitelist: string;
          orderTracking: {
            integrator: string;
            integratorPercentage: BigNumberish;
            orderTag: BytesLike;
          };
          takerIsSigner: boolean;
        };
        signature: { signatureType: BigNumberish; signatureData: BytesLike };
        permit: BytesLike;
      },
      overrides?: CallOverrides
    ): Promise<[string]>;

    hashOrder(
      order: {
        orderCreationTimestamp: BigNumberish;
        orderExpirationTimestamp: BigNumberish;
        makerAsset: string;
        optionAttributes: {
          underlyingAsset: string;
          oracle: string;
          expiryTime: BigNumberish;
          isCall: boolean;
          strikePrice: BigNumberish;
        };
        maker: string;
        taker: string;
        allowedSender: string;
        makingAmount: BigNumberish;
        takingAmount: BigNumberish;
        whitelist: string;
        orderTracking: {
          integrator: string;
          integratorPercentage: BigNumberish;
          orderTag: BytesLike;
        };
        takerIsSigner: boolean;
      },
      overrides?: CallOverrides
    ): Promise<[string]>;

    "hashOrder((uint64,uint64,address,(address,address,uint88,bool,uint256),address,address,address,uint256,uint256,address,(address,uint256,bytes32),bool))"(
      order: {
        orderCreationTimestamp: BigNumberish;
        orderExpirationTimestamp: BigNumberish;
        makerAsset: string;
        optionAttributes: {
          underlyingAsset: string;
          oracle: string;
          expiryTime: BigNumberish;
          isCall: boolean;
          strikePrice: BigNumberish;
        };
        maker: string;
        taker: string;
        allowedSender: string;
        makingAmount: BigNumberish;
        takingAmount: BigNumberish;
        whitelist: string;
        orderTracking: {
          integrator: string;
          integratorPercentage: BigNumberish;
          orderTag: BytesLike;
        };
        takerIsSigner: boolean;
      },
      overrides?: CallOverrides
    ): Promise<[string]>;

    isInvalidatedOrder(
      arg0: BytesLike,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    "isInvalidatedOrder(bytes32)"(
      arg0: BytesLike,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    makerCancelTime(
      arg0: string,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    "makerCancelTime(address)"(
      arg0: string,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    name(overrides?: CallOverrides): Promise<[string]>;

    "name()"(overrides?: CallOverrides): Promise<[string]>;

    onERC1155Received(
      arg0: string,
      arg1: string,
      arg2: BigNumberish,
      arg3: BigNumberish,
      arg4: BytesLike,
      overrides?: CallOverrides
    ): Promise<[string] & { selector: string }>;

    "onERC1155Received(address,address,uint256,uint256,bytes)"(
      arg0: string,
      arg1: string,
      arg2: BigNumberish,
      arg3: BigNumberish,
      arg4: BytesLike,
      overrides?: CallOverrides
    ): Promise<[string] & { selector: string }>;

    optionsFactory(overrides?: CallOverrides): Promise<[string]>;

    "optionsFactory()"(overrides?: CallOverrides): Promise<[string]>;

    owner(overrides?: CallOverrides): Promise<[string]>;

    "owner()"(overrides?: CallOverrides): Promise<[string]>;

    pendingOwner(overrides?: CallOverrides): Promise<[string]>;

    "pendingOwner()"(overrides?: CallOverrides): Promise<[string]>;

    protocolFee(overrides?: CallOverrides): Promise<[BigNumber]>;

    "protocolFee()"(overrides?: CallOverrides): Promise<[BigNumber]>;

    renounceOwnership(overrides?: Overrides): Promise<ContractTransaction>;

    "renounceOwnership()"(overrides?: Overrides): Promise<ContractTransaction>;

    sendFees(
      _to: string,
      _token: string,
      _amount: BigNumberish,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    "sendFees(address,address,uint256)"(
      _to: string,
      _token: string,
      _amount: BigNumberish,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    setProtocolFee(
      _protocolFee: BigNumberish,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    "setProtocolFee(uint256)"(
      _protocolFee: BigNumberish,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    transferOwnership(
      newOwner: string,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    "transferOwnership(address)"(
      newOwner: string,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    version(overrides?: CallOverrides): Promise<[string]>;

    "version()"(overrides?: CallOverrides): Promise<[string]>;
  };

  CHAIN_TOKEN_ADDRESS(overrides?: CallOverrides): Promise<string>;

  "CHAIN_TOKEN_ADDRESS()"(overrides?: CallOverrides): Promise<string>;

  DOMAIN_SEPARATOR(overrides?: CallOverrides): Promise<string>;

  "DOMAIN_SEPARATOR()"(overrides?: CallOverrides): Promise<string>;

  EIP712_DOMAIN_TYPEHASH(overrides?: CallOverrides): Promise<string>;

  "EIP712_DOMAIN_TYPEHASH()"(overrides?: CallOverrides): Promise<string>;

  META_ORDER_PROTOCOL_TYPEHASH(overrides?: CallOverrides): Promise<string>;

  "META_ORDER_PROTOCOL_TYPEHASH()"(overrides?: CallOverrides): Promise<string>;

  OPTION_ATTRIBUTES_TYPEHASH(overrides?: CallOverrides): Promise<string>;

  "OPTION_ATTRIBUTES_TYPEHASH()"(overrides?: CallOverrides): Promise<string>;

  ORDER_TRACKING_TYPEHASH(overrides?: CallOverrides): Promise<string>;

  "ORDER_TRACKING_TYPEHASH()"(overrides?: CallOverrides): Promise<string>;

  ROLLA_ORDER_PROTOCOL_TYPEHASH(overrides?: CallOverrides): Promise<string>;

  "ROLLA_ORDER_PROTOCOL_TYPEHASH()"(overrides?: CallOverrides): Promise<string>;

  SIGNATURE_TYPEHASH(overrides?: CallOverrides): Promise<string>;

  "SIGNATURE_TYPEHASH()"(overrides?: CallOverrides): Promise<string>;

  acceptOwnership(overrides?: Overrides): Promise<ContractTransaction>;

  "acceptOwnership()"(overrides?: Overrides): Promise<ContractTransaction>;

  cancelOrder(
    order: {
      orderCreationTimestamp: BigNumberish;
      orderExpirationTimestamp: BigNumberish;
      makerAsset: string;
      optionAttributes: {
        underlyingAsset: string;
        oracle: string;
        expiryTime: BigNumberish;
        isCall: boolean;
        strikePrice: BigNumberish;
      };
      maker: string;
      taker: string;
      allowedSender: string;
      makingAmount: BigNumberish;
      takingAmount: BigNumberish;
      whitelist: string;
      orderTracking: {
        integrator: string;
        integratorPercentage: BigNumberish;
        orderTag: BytesLike;
      };
      takerIsSigner: boolean;
    },
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  "cancelOrder((uint64,uint64,address,(address,address,uint88,bool,uint256),address,address,address,uint256,uint256,address,(address,uint256,bytes32),bool))"(
    order: {
      orderCreationTimestamp: BigNumberish;
      orderExpirationTimestamp: BigNumberish;
      makerAsset: string;
      optionAttributes: {
        underlyingAsset: string;
        oracle: string;
        expiryTime: BigNumberish;
        isCall: boolean;
        strikePrice: BigNumberish;
      };
      maker: string;
      taker: string;
      allowedSender: string;
      makingAmount: BigNumberish;
      takingAmount: BigNumberish;
      whitelist: string;
      orderTracking: {
        integrator: string;
        integratorPercentage: BigNumberish;
        orderTag: BytesLike;
      };
      takerIsSigner: boolean;
    },
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  cancelOrdersUpTo(
    timestamp: BigNumberish,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  "cancelOrdersUpTo(uint64)"(
    timestamp: BigNumberish,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  chainTokenWrapper(overrides?: CallOverrides): Promise<string>;

  "chainTokenWrapper()"(overrides?: CallOverrides): Promise<string>;

  collateralToken(overrides?: CallOverrides): Promise<string>;

  "collateralToken()"(overrides?: CallOverrides): Promise<string>;

  controller(overrides?: CallOverrides): Promise<string>;

  "controller()"(overrides?: CallOverrides): Promise<string>;

  executeMetaTransaction(
    metaOrder: {
      functionType: BigNumberish;
      nonce: BigNumberish;
      deadline: BigNumberish;
      from: string;
      order: {
        orderCreationTimestamp: BigNumberish;
        orderExpirationTimestamp: BigNumberish;
        makerAsset: string;
        optionAttributes: {
          underlyingAsset: string;
          oracle: string;
          expiryTime: BigNumberish;
          isCall: boolean;
          strikePrice: BigNumberish;
        };
        maker: string;
        taker: string;
        allowedSender: string;
        makingAmount: BigNumberish;
        takingAmount: BigNumberish;
        whitelist: string;
        orderTracking: {
          integrator: string;
          integratorPercentage: BigNumberish;
          orderTag: BytesLike;
        };
        takerIsSigner: boolean;
      };
      signature: { signatureType: BigNumberish; signatureData: BytesLike };
      permit: BytesLike;
    },
    r: BytesLike,
    s: BytesLike,
    v: BigNumberish,
    signatureType: BigNumberish,
    overrides?: PayableOverrides
  ): Promise<ContractTransaction>;

  "executeMetaTransaction((uint8,uint256,uint256,address,(uint64,uint64,address,(address,address,uint88,bool,uint256),address,address,address,uint256,uint256,address,(address,uint256,bytes32),bool),(uint8,bytes),bytes),bytes32,bytes32,uint8,uint8)"(
    metaOrder: {
      functionType: BigNumberish;
      nonce: BigNumberish;
      deadline: BigNumberish;
      from: string;
      order: {
        orderCreationTimestamp: BigNumberish;
        orderExpirationTimestamp: BigNumberish;
        makerAsset: string;
        optionAttributes: {
          underlyingAsset: string;
          oracle: string;
          expiryTime: BigNumberish;
          isCall: boolean;
          strikePrice: BigNumberish;
        };
        maker: string;
        taker: string;
        allowedSender: string;
        makingAmount: BigNumberish;
        takingAmount: BigNumberish;
        whitelist: string;
        orderTracking: {
          integrator: string;
          integratorPercentage: BigNumberish;
          orderTag: BytesLike;
        };
        takerIsSigner: boolean;
      };
      signature: { signatureType: BigNumberish; signatureData: BytesLike };
      permit: BytesLike;
    },
    r: BytesLike,
    s: BytesLike,
    v: BigNumberish,
    signatureType: BigNumberish,
    overrides?: PayableOverrides
  ): Promise<ContractTransaction>;

  fillOrder(
    order: {
      orderCreationTimestamp: BigNumberish;
      orderExpirationTimestamp: BigNumberish;
      makerAsset: string;
      optionAttributes: {
        underlyingAsset: string;
        oracle: string;
        expiryTime: BigNumberish;
        isCall: boolean;
        strikePrice: BigNumberish;
      };
      maker: string;
      taker: string;
      allowedSender: string;
      makingAmount: BigNumberish;
      takingAmount: BigNumberish;
      whitelist: string;
      orderTracking: {
        integrator: string;
        integratorPercentage: BigNumberish;
        orderTag: BytesLike;
      };
      takerIsSigner: boolean;
    },
    signature: { signatureType: BigNumberish; signatureData: BytesLike },
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  "fillOrder((uint64,uint64,address,(address,address,uint88,bool,uint256),address,address,address,uint256,uint256,address,(address,uint256,bytes32),bool),(uint8,bytes))"(
    order: {
      orderCreationTimestamp: BigNumberish;
      orderExpirationTimestamp: BigNumberish;
      makerAsset: string;
      optionAttributes: {
        underlyingAsset: string;
        oracle: string;
        expiryTime: BigNumberish;
        isCall: boolean;
        strikePrice: BigNumberish;
      };
      maker: string;
      taker: string;
      allowedSender: string;
      makingAmount: BigNumberish;
      takingAmount: BigNumberish;
      whitelist: string;
      orderTracking: {
        integrator: string;
        integratorPercentage: BigNumberish;
        orderTag: BytesLike;
      };
      takerIsSigner: boolean;
    },
    signature: { signatureType: BigNumberish; signatureData: BytesLike },
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  fillOrderWithChainToken(
    order: {
      orderCreationTimestamp: BigNumberish;
      orderExpirationTimestamp: BigNumberish;
      makerAsset: string;
      optionAttributes: {
        underlyingAsset: string;
        oracle: string;
        expiryTime: BigNumberish;
        isCall: boolean;
        strikePrice: BigNumberish;
      };
      maker: string;
      taker: string;
      allowedSender: string;
      makingAmount: BigNumberish;
      takingAmount: BigNumberish;
      whitelist: string;
      orderTracking: {
        integrator: string;
        integratorPercentage: BigNumberish;
        orderTag: BytesLike;
      };
      takerIsSigner: boolean;
    },
    signature: { signatureType: BigNumberish; signatureData: BytesLike },
    overrides?: PayableOverrides
  ): Promise<ContractTransaction>;

  "fillOrderWithChainToken((uint64,uint64,address,(address,address,uint88,bool,uint256),address,address,address,uint256,uint256,address,(address,uint256,bytes32),bool),(uint8,bytes))"(
    order: {
      orderCreationTimestamp: BigNumberish;
      orderExpirationTimestamp: BigNumberish;
      makerAsset: string;
      optionAttributes: {
        underlyingAsset: string;
        oracle: string;
        expiryTime: BigNumberish;
        isCall: boolean;
        strikePrice: BigNumberish;
      };
      maker: string;
      taker: string;
      allowedSender: string;
      makingAmount: BigNumberish;
      takingAmount: BigNumberish;
      whitelist: string;
      orderTracking: {
        integrator: string;
        integratorPercentage: BigNumberish;
        orderTag: BytesLike;
      };
      takerIsSigner: boolean;
    },
    signature: { signatureType: BigNumberish; signatureData: BytesLike },
    overrides?: PayableOverrides
  ): Promise<ContractTransaction>;

  fillOrderWithPermit(
    order: {
      orderCreationTimestamp: BigNumberish;
      orderExpirationTimestamp: BigNumberish;
      makerAsset: string;
      optionAttributes: {
        underlyingAsset: string;
        oracle: string;
        expiryTime: BigNumberish;
        isCall: boolean;
        strikePrice: BigNumberish;
      };
      maker: string;
      taker: string;
      allowedSender: string;
      makingAmount: BigNumberish;
      takingAmount: BigNumberish;
      whitelist: string;
      orderTracking: {
        integrator: string;
        integratorPercentage: BigNumberish;
        orderTag: BytesLike;
      };
      takerIsSigner: boolean;
    },
    signature: { signatureType: BigNumberish; signatureData: BytesLike },
    permit: BytesLike,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  "fillOrderWithPermit((uint64,uint64,address,(address,address,uint88,bool,uint256),address,address,address,uint256,uint256,address,(address,uint256,bytes32),bool),(uint8,bytes),bytes)"(
    order: {
      orderCreationTimestamp: BigNumberish;
      orderExpirationTimestamp: BigNumberish;
      makerAsset: string;
      optionAttributes: {
        underlyingAsset: string;
        oracle: string;
        expiryTime: BigNumberish;
        isCall: boolean;
        strikePrice: BigNumberish;
      };
      maker: string;
      taker: string;
      allowedSender: string;
      makingAmount: BigNumberish;
      takingAmount: BigNumberish;
      whitelist: string;
      orderTracking: {
        integrator: string;
        integratorPercentage: BigNumberish;
        orderTag: BytesLike;
      };
      takerIsSigner: boolean;
    },
    signature: { signatureType: BigNumberish; signatureData: BytesLike },
    permit: BytesLike,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  getNonce(user: string, overrides?: CallOverrides): Promise<BigNumber>;

  "getNonce(address)"(
    user: string,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  hashMetaOrder(
    metaOrder: {
      functionType: BigNumberish;
      nonce: BigNumberish;
      deadline: BigNumberish;
      from: string;
      order: {
        orderCreationTimestamp: BigNumberish;
        orderExpirationTimestamp: BigNumberish;
        makerAsset: string;
        optionAttributes: {
          underlyingAsset: string;
          oracle: string;
          expiryTime: BigNumberish;
          isCall: boolean;
          strikePrice: BigNumberish;
        };
        maker: string;
        taker: string;
        allowedSender: string;
        makingAmount: BigNumberish;
        takingAmount: BigNumberish;
        whitelist: string;
        orderTracking: {
          integrator: string;
          integratorPercentage: BigNumberish;
          orderTag: BytesLike;
        };
        takerIsSigner: boolean;
      };
      signature: { signatureType: BigNumberish; signatureData: BytesLike };
      permit: BytesLike;
    },
    overrides?: CallOverrides
  ): Promise<string>;

  "hashMetaOrder((uint8,uint256,uint256,address,(uint64,uint64,address,(address,address,uint88,bool,uint256),address,address,address,uint256,uint256,address,(address,uint256,bytes32),bool),(uint8,bytes),bytes))"(
    metaOrder: {
      functionType: BigNumberish;
      nonce: BigNumberish;
      deadline: BigNumberish;
      from: string;
      order: {
        orderCreationTimestamp: BigNumberish;
        orderExpirationTimestamp: BigNumberish;
        makerAsset: string;
        optionAttributes: {
          underlyingAsset: string;
          oracle: string;
          expiryTime: BigNumberish;
          isCall: boolean;
          strikePrice: BigNumberish;
        };
        maker: string;
        taker: string;
        allowedSender: string;
        makingAmount: BigNumberish;
        takingAmount: BigNumberish;
        whitelist: string;
        orderTracking: {
          integrator: string;
          integratorPercentage: BigNumberish;
          orderTag: BytesLike;
        };
        takerIsSigner: boolean;
      };
      signature: { signatureType: BigNumberish; signatureData: BytesLike };
      permit: BytesLike;
    },
    overrides?: CallOverrides
  ): Promise<string>;

  hashOrder(
    order: {
      orderCreationTimestamp: BigNumberish;
      orderExpirationTimestamp: BigNumberish;
      makerAsset: string;
      optionAttributes: {
        underlyingAsset: string;
        oracle: string;
        expiryTime: BigNumberish;
        isCall: boolean;
        strikePrice: BigNumberish;
      };
      maker: string;
      taker: string;
      allowedSender: string;
      makingAmount: BigNumberish;
      takingAmount: BigNumberish;
      whitelist: string;
      orderTracking: {
        integrator: string;
        integratorPercentage: BigNumberish;
        orderTag: BytesLike;
      };
      takerIsSigner: boolean;
    },
    overrides?: CallOverrides
  ): Promise<string>;

  "hashOrder((uint64,uint64,address,(address,address,uint88,bool,uint256),address,address,address,uint256,uint256,address,(address,uint256,bytes32),bool))"(
    order: {
      orderCreationTimestamp: BigNumberish;
      orderExpirationTimestamp: BigNumberish;
      makerAsset: string;
      optionAttributes: {
        underlyingAsset: string;
        oracle: string;
        expiryTime: BigNumberish;
        isCall: boolean;
        strikePrice: BigNumberish;
      };
      maker: string;
      taker: string;
      allowedSender: string;
      makingAmount: BigNumberish;
      takingAmount: BigNumberish;
      whitelist: string;
      orderTracking: {
        integrator: string;
        integratorPercentage: BigNumberish;
        orderTag: BytesLike;
      };
      takerIsSigner: boolean;
    },
    overrides?: CallOverrides
  ): Promise<string>;

  isInvalidatedOrder(
    arg0: BytesLike,
    overrides?: CallOverrides
  ): Promise<boolean>;

  "isInvalidatedOrder(bytes32)"(
    arg0: BytesLike,
    overrides?: CallOverrides
  ): Promise<boolean>;

  makerCancelTime(arg0: string, overrides?: CallOverrides): Promise<BigNumber>;

  "makerCancelTime(address)"(
    arg0: string,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  name(overrides?: CallOverrides): Promise<string>;

  "name()"(overrides?: CallOverrides): Promise<string>;

  onERC1155Received(
    arg0: string,
    arg1: string,
    arg2: BigNumberish,
    arg3: BigNumberish,
    arg4: BytesLike,
    overrides?: CallOverrides
  ): Promise<string>;

  "onERC1155Received(address,address,uint256,uint256,bytes)"(
    arg0: string,
    arg1: string,
    arg2: BigNumberish,
    arg3: BigNumberish,
    arg4: BytesLike,
    overrides?: CallOverrides
  ): Promise<string>;

  optionsFactory(overrides?: CallOverrides): Promise<string>;

  "optionsFactory()"(overrides?: CallOverrides): Promise<string>;

  owner(overrides?: CallOverrides): Promise<string>;

  "owner()"(overrides?: CallOverrides): Promise<string>;

  pendingOwner(overrides?: CallOverrides): Promise<string>;

  "pendingOwner()"(overrides?: CallOverrides): Promise<string>;

  protocolFee(overrides?: CallOverrides): Promise<BigNumber>;

  "protocolFee()"(overrides?: CallOverrides): Promise<BigNumber>;

  renounceOwnership(overrides?: Overrides): Promise<ContractTransaction>;

  "renounceOwnership()"(overrides?: Overrides): Promise<ContractTransaction>;

  sendFees(
    _to: string,
    _token: string,
    _amount: BigNumberish,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  "sendFees(address,address,uint256)"(
    _to: string,
    _token: string,
    _amount: BigNumberish,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  setProtocolFee(
    _protocolFee: BigNumberish,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  "setProtocolFee(uint256)"(
    _protocolFee: BigNumberish,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  transferOwnership(
    newOwner: string,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  "transferOwnership(address)"(
    newOwner: string,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  version(overrides?: CallOverrides): Promise<string>;

  "version()"(overrides?: CallOverrides): Promise<string>;

  callStatic: {
    CHAIN_TOKEN_ADDRESS(overrides?: CallOverrides): Promise<string>;

    "CHAIN_TOKEN_ADDRESS()"(overrides?: CallOverrides): Promise<string>;

    DOMAIN_SEPARATOR(overrides?: CallOverrides): Promise<string>;

    "DOMAIN_SEPARATOR()"(overrides?: CallOverrides): Promise<string>;

    EIP712_DOMAIN_TYPEHASH(overrides?: CallOverrides): Promise<string>;

    "EIP712_DOMAIN_TYPEHASH()"(overrides?: CallOverrides): Promise<string>;

    META_ORDER_PROTOCOL_TYPEHASH(overrides?: CallOverrides): Promise<string>;

    "META_ORDER_PROTOCOL_TYPEHASH()"(
      overrides?: CallOverrides
    ): Promise<string>;

    OPTION_ATTRIBUTES_TYPEHASH(overrides?: CallOverrides): Promise<string>;

    "OPTION_ATTRIBUTES_TYPEHASH()"(overrides?: CallOverrides): Promise<string>;

    ORDER_TRACKING_TYPEHASH(overrides?: CallOverrides): Promise<string>;

    "ORDER_TRACKING_TYPEHASH()"(overrides?: CallOverrides): Promise<string>;

    ROLLA_ORDER_PROTOCOL_TYPEHASH(overrides?: CallOverrides): Promise<string>;

    "ROLLA_ORDER_PROTOCOL_TYPEHASH()"(
      overrides?: CallOverrides
    ): Promise<string>;

    SIGNATURE_TYPEHASH(overrides?: CallOverrides): Promise<string>;

    "SIGNATURE_TYPEHASH()"(overrides?: CallOverrides): Promise<string>;

    acceptOwnership(overrides?: CallOverrides): Promise<void>;

    "acceptOwnership()"(overrides?: CallOverrides): Promise<void>;

    cancelOrder(
      order: {
        orderCreationTimestamp: BigNumberish;
        orderExpirationTimestamp: BigNumberish;
        makerAsset: string;
        optionAttributes: {
          underlyingAsset: string;
          oracle: string;
          expiryTime: BigNumberish;
          isCall: boolean;
          strikePrice: BigNumberish;
        };
        maker: string;
        taker: string;
        allowedSender: string;
        makingAmount: BigNumberish;
        takingAmount: BigNumberish;
        whitelist: string;
        orderTracking: {
          integrator: string;
          integratorPercentage: BigNumberish;
          orderTag: BytesLike;
        };
        takerIsSigner: boolean;
      },
      overrides?: CallOverrides
    ): Promise<void>;

    "cancelOrder((uint64,uint64,address,(address,address,uint88,bool,uint256),address,address,address,uint256,uint256,address,(address,uint256,bytes32),bool))"(
      order: {
        orderCreationTimestamp: BigNumberish;
        orderExpirationTimestamp: BigNumberish;
        makerAsset: string;
        optionAttributes: {
          underlyingAsset: string;
          oracle: string;
          expiryTime: BigNumberish;
          isCall: boolean;
          strikePrice: BigNumberish;
        };
        maker: string;
        taker: string;
        allowedSender: string;
        makingAmount: BigNumberish;
        takingAmount: BigNumberish;
        whitelist: string;
        orderTracking: {
          integrator: string;
          integratorPercentage: BigNumberish;
          orderTag: BytesLike;
        };
        takerIsSigner: boolean;
      },
      overrides?: CallOverrides
    ): Promise<void>;

    cancelOrdersUpTo(
      timestamp: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    "cancelOrdersUpTo(uint64)"(
      timestamp: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    chainTokenWrapper(overrides?: CallOverrides): Promise<string>;

    "chainTokenWrapper()"(overrides?: CallOverrides): Promise<string>;

    collateralToken(overrides?: CallOverrides): Promise<string>;

    "collateralToken()"(overrides?: CallOverrides): Promise<string>;

    controller(overrides?: CallOverrides): Promise<string>;

    "controller()"(overrides?: CallOverrides): Promise<string>;

    executeMetaTransaction(
      metaOrder: {
        functionType: BigNumberish;
        nonce: BigNumberish;
        deadline: BigNumberish;
        from: string;
        order: {
          orderCreationTimestamp: BigNumberish;
          orderExpirationTimestamp: BigNumberish;
          makerAsset: string;
          optionAttributes: {
            underlyingAsset: string;
            oracle: string;
            expiryTime: BigNumberish;
            isCall: boolean;
            strikePrice: BigNumberish;
          };
          maker: string;
          taker: string;
          allowedSender: string;
          makingAmount: BigNumberish;
          takingAmount: BigNumberish;
          whitelist: string;
          orderTracking: {
            integrator: string;
            integratorPercentage: BigNumberish;
            orderTag: BytesLike;
          };
          takerIsSigner: boolean;
        };
        signature: { signatureType: BigNumberish; signatureData: BytesLike };
        permit: BytesLike;
      },
      r: BytesLike,
      s: BytesLike,
      v: BigNumberish,
      signatureType: BigNumberish,
      overrides?: CallOverrides
    ): Promise<string>;

    "executeMetaTransaction((uint8,uint256,uint256,address,(uint64,uint64,address,(address,address,uint88,bool,uint256),address,address,address,uint256,uint256,address,(address,uint256,bytes32),bool),(uint8,bytes),bytes),bytes32,bytes32,uint8,uint8)"(
      metaOrder: {
        functionType: BigNumberish;
        nonce: BigNumberish;
        deadline: BigNumberish;
        from: string;
        order: {
          orderCreationTimestamp: BigNumberish;
          orderExpirationTimestamp: BigNumberish;
          makerAsset: string;
          optionAttributes: {
            underlyingAsset: string;
            oracle: string;
            expiryTime: BigNumberish;
            isCall: boolean;
            strikePrice: BigNumberish;
          };
          maker: string;
          taker: string;
          allowedSender: string;
          makingAmount: BigNumberish;
          takingAmount: BigNumberish;
          whitelist: string;
          orderTracking: {
            integrator: string;
            integratorPercentage: BigNumberish;
            orderTag: BytesLike;
          };
          takerIsSigner: boolean;
        };
        signature: { signatureType: BigNumberish; signatureData: BytesLike };
        permit: BytesLike;
      },
      r: BytesLike,
      s: BytesLike,
      v: BigNumberish,
      signatureType: BigNumberish,
      overrides?: CallOverrides
    ): Promise<string>;

    fillOrder(
      order: {
        orderCreationTimestamp: BigNumberish;
        orderExpirationTimestamp: BigNumberish;
        makerAsset: string;
        optionAttributes: {
          underlyingAsset: string;
          oracle: string;
          expiryTime: BigNumberish;
          isCall: boolean;
          strikePrice: BigNumberish;
        };
        maker: string;
        taker: string;
        allowedSender: string;
        makingAmount: BigNumberish;
        takingAmount: BigNumberish;
        whitelist: string;
        orderTracking: {
          integrator: string;
          integratorPercentage: BigNumberish;
          orderTag: BytesLike;
        };
        takerIsSigner: boolean;
      },
      signature: { signatureType: BigNumberish; signatureData: BytesLike },
      overrides?: CallOverrides
    ): Promise<void>;

    "fillOrder((uint64,uint64,address,(address,address,uint88,bool,uint256),address,address,address,uint256,uint256,address,(address,uint256,bytes32),bool),(uint8,bytes))"(
      order: {
        orderCreationTimestamp: BigNumberish;
        orderExpirationTimestamp: BigNumberish;
        makerAsset: string;
        optionAttributes: {
          underlyingAsset: string;
          oracle: string;
          expiryTime: BigNumberish;
          isCall: boolean;
          strikePrice: BigNumberish;
        };
        maker: string;
        taker: string;
        allowedSender: string;
        makingAmount: BigNumberish;
        takingAmount: BigNumberish;
        whitelist: string;
        orderTracking: {
          integrator: string;
          integratorPercentage: BigNumberish;
          orderTag: BytesLike;
        };
        takerIsSigner: boolean;
      },
      signature: { signatureType: BigNumberish; signatureData: BytesLike },
      overrides?: CallOverrides
    ): Promise<void>;

    fillOrderWithChainToken(
      order: {
        orderCreationTimestamp: BigNumberish;
        orderExpirationTimestamp: BigNumberish;
        makerAsset: string;
        optionAttributes: {
          underlyingAsset: string;
          oracle: string;
          expiryTime: BigNumberish;
          isCall: boolean;
          strikePrice: BigNumberish;
        };
        maker: string;
        taker: string;
        allowedSender: string;
        makingAmount: BigNumberish;
        takingAmount: BigNumberish;
        whitelist: string;
        orderTracking: {
          integrator: string;
          integratorPercentage: BigNumberish;
          orderTag: BytesLike;
        };
        takerIsSigner: boolean;
      },
      signature: { signatureType: BigNumberish; signatureData: BytesLike },
      overrides?: CallOverrides
    ): Promise<void>;

    "fillOrderWithChainToken((uint64,uint64,address,(address,address,uint88,bool,uint256),address,address,address,uint256,uint256,address,(address,uint256,bytes32),bool),(uint8,bytes))"(
      order: {
        orderCreationTimestamp: BigNumberish;
        orderExpirationTimestamp: BigNumberish;
        makerAsset: string;
        optionAttributes: {
          underlyingAsset: string;
          oracle: string;
          expiryTime: BigNumberish;
          isCall: boolean;
          strikePrice: BigNumberish;
        };
        maker: string;
        taker: string;
        allowedSender: string;
        makingAmount: BigNumberish;
        takingAmount: BigNumberish;
        whitelist: string;
        orderTracking: {
          integrator: string;
          integratorPercentage: BigNumberish;
          orderTag: BytesLike;
        };
        takerIsSigner: boolean;
      },
      signature: { signatureType: BigNumberish; signatureData: BytesLike },
      overrides?: CallOverrides
    ): Promise<void>;

    fillOrderWithPermit(
      order: {
        orderCreationTimestamp: BigNumberish;
        orderExpirationTimestamp: BigNumberish;
        makerAsset: string;
        optionAttributes: {
          underlyingAsset: string;
          oracle: string;
          expiryTime: BigNumberish;
          isCall: boolean;
          strikePrice: BigNumberish;
        };
        maker: string;
        taker: string;
        allowedSender: string;
        makingAmount: BigNumberish;
        takingAmount: BigNumberish;
        whitelist: string;
        orderTracking: {
          integrator: string;
          integratorPercentage: BigNumberish;
          orderTag: BytesLike;
        };
        takerIsSigner: boolean;
      },
      signature: { signatureType: BigNumberish; signatureData: BytesLike },
      permit: BytesLike,
      overrides?: CallOverrides
    ): Promise<void>;

    "fillOrderWithPermit((uint64,uint64,address,(address,address,uint88,bool,uint256),address,address,address,uint256,uint256,address,(address,uint256,bytes32),bool),(uint8,bytes),bytes)"(
      order: {
        orderCreationTimestamp: BigNumberish;
        orderExpirationTimestamp: BigNumberish;
        makerAsset: string;
        optionAttributes: {
          underlyingAsset: string;
          oracle: string;
          expiryTime: BigNumberish;
          isCall: boolean;
          strikePrice: BigNumberish;
        };
        maker: string;
        taker: string;
        allowedSender: string;
        makingAmount: BigNumberish;
        takingAmount: BigNumberish;
        whitelist: string;
        orderTracking: {
          integrator: string;
          integratorPercentage: BigNumberish;
          orderTag: BytesLike;
        };
        takerIsSigner: boolean;
      },
      signature: { signatureType: BigNumberish; signatureData: BytesLike },
      permit: BytesLike,
      overrides?: CallOverrides
    ): Promise<void>;

    getNonce(user: string, overrides?: CallOverrides): Promise<BigNumber>;

    "getNonce(address)"(
      user: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    hashMetaOrder(
      metaOrder: {
        functionType: BigNumberish;
        nonce: BigNumberish;
        deadline: BigNumberish;
        from: string;
        order: {
          orderCreationTimestamp: BigNumberish;
          orderExpirationTimestamp: BigNumberish;
          makerAsset: string;
          optionAttributes: {
            underlyingAsset: string;
            oracle: string;
            expiryTime: BigNumberish;
            isCall: boolean;
            strikePrice: BigNumberish;
          };
          maker: string;
          taker: string;
          allowedSender: string;
          makingAmount: BigNumberish;
          takingAmount: BigNumberish;
          whitelist: string;
          orderTracking: {
            integrator: string;
            integratorPercentage: BigNumberish;
            orderTag: BytesLike;
          };
          takerIsSigner: boolean;
        };
        signature: { signatureType: BigNumberish; signatureData: BytesLike };
        permit: BytesLike;
      },
      overrides?: CallOverrides
    ): Promise<string>;

    "hashMetaOrder((uint8,uint256,uint256,address,(uint64,uint64,address,(address,address,uint88,bool,uint256),address,address,address,uint256,uint256,address,(address,uint256,bytes32),bool),(uint8,bytes),bytes))"(
      metaOrder: {
        functionType: BigNumberish;
        nonce: BigNumberish;
        deadline: BigNumberish;
        from: string;
        order: {
          orderCreationTimestamp: BigNumberish;
          orderExpirationTimestamp: BigNumberish;
          makerAsset: string;
          optionAttributes: {
            underlyingAsset: string;
            oracle: string;
            expiryTime: BigNumberish;
            isCall: boolean;
            strikePrice: BigNumberish;
          };
          maker: string;
          taker: string;
          allowedSender: string;
          makingAmount: BigNumberish;
          takingAmount: BigNumberish;
          whitelist: string;
          orderTracking: {
            integrator: string;
            integratorPercentage: BigNumberish;
            orderTag: BytesLike;
          };
          takerIsSigner: boolean;
        };
        signature: { signatureType: BigNumberish; signatureData: BytesLike };
        permit: BytesLike;
      },
      overrides?: CallOverrides
    ): Promise<string>;

    hashOrder(
      order: {
        orderCreationTimestamp: BigNumberish;
        orderExpirationTimestamp: BigNumberish;
        makerAsset: string;
        optionAttributes: {
          underlyingAsset: string;
          oracle: string;
          expiryTime: BigNumberish;
          isCall: boolean;
          strikePrice: BigNumberish;
        };
        maker: string;
        taker: string;
        allowedSender: string;
        makingAmount: BigNumberish;
        takingAmount: BigNumberish;
        whitelist: string;
        orderTracking: {
          integrator: string;
          integratorPercentage: BigNumberish;
          orderTag: BytesLike;
        };
        takerIsSigner: boolean;
      },
      overrides?: CallOverrides
    ): Promise<string>;

    "hashOrder((uint64,uint64,address,(address,address,uint88,bool,uint256),address,address,address,uint256,uint256,address,(address,uint256,bytes32),bool))"(
      order: {
        orderCreationTimestamp: BigNumberish;
        orderExpirationTimestamp: BigNumberish;
        makerAsset: string;
        optionAttributes: {
          underlyingAsset: string;
          oracle: string;
          expiryTime: BigNumberish;
          isCall: boolean;
          strikePrice: BigNumberish;
        };
        maker: string;
        taker: string;
        allowedSender: string;
        makingAmount: BigNumberish;
        takingAmount: BigNumberish;
        whitelist: string;
        orderTracking: {
          integrator: string;
          integratorPercentage: BigNumberish;
          orderTag: BytesLike;
        };
        takerIsSigner: boolean;
      },
      overrides?: CallOverrides
    ): Promise<string>;

    isInvalidatedOrder(
      arg0: BytesLike,
      overrides?: CallOverrides
    ): Promise<boolean>;

    "isInvalidatedOrder(bytes32)"(
      arg0: BytesLike,
      overrides?: CallOverrides
    ): Promise<boolean>;

    makerCancelTime(
      arg0: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    "makerCancelTime(address)"(
      arg0: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    name(overrides?: CallOverrides): Promise<string>;

    "name()"(overrides?: CallOverrides): Promise<string>;

    onERC1155Received(
      arg0: string,
      arg1: string,
      arg2: BigNumberish,
      arg3: BigNumberish,
      arg4: BytesLike,
      overrides?: CallOverrides
    ): Promise<string>;

    "onERC1155Received(address,address,uint256,uint256,bytes)"(
      arg0: string,
      arg1: string,
      arg2: BigNumberish,
      arg3: BigNumberish,
      arg4: BytesLike,
      overrides?: CallOverrides
    ): Promise<string>;

    optionsFactory(overrides?: CallOverrides): Promise<string>;

    "optionsFactory()"(overrides?: CallOverrides): Promise<string>;

    owner(overrides?: CallOverrides): Promise<string>;

    "owner()"(overrides?: CallOverrides): Promise<string>;

    pendingOwner(overrides?: CallOverrides): Promise<string>;

    "pendingOwner()"(overrides?: CallOverrides): Promise<string>;

    protocolFee(overrides?: CallOverrides): Promise<BigNumber>;

    "protocolFee()"(overrides?: CallOverrides): Promise<BigNumber>;

    renounceOwnership(overrides?: CallOverrides): Promise<void>;

    "renounceOwnership()"(overrides?: CallOverrides): Promise<void>;

    sendFees(
      _to: string,
      _token: string,
      _amount: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    "sendFees(address,address,uint256)"(
      _to: string,
      _token: string,
      _amount: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    setProtocolFee(
      _protocolFee: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    "setProtocolFee(uint256)"(
      _protocolFee: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    transferOwnership(
      newOwner: string,
      overrides?: CallOverrides
    ): Promise<void>;

    "transferOwnership(address)"(
      newOwner: string,
      overrides?: CallOverrides
    ): Promise<void>;

    version(overrides?: CallOverrides): Promise<string>;

    "version()"(overrides?: CallOverrides): Promise<string>;
  };

  filters: {
    FeesSent(_to: null, token: null, amount: null): EventFilter;

    MetaTransactionExecuted(
      userAddress: string | null,
      relayerAddress: string | null,
      nonce: null
    ): EventFilter;

    OrderCancelled(
      orderHash: BytesLike | null,
      maker: string | null
    ): EventFilter;

    OrderFilled(
      orderHash: BytesLike | null,
      order: null,
      makingAmount: null,
      takingAmount: null,
      integrator: null,
      orderTag: null,
      protocolPayout: null,
      integratorPayout: null,
      takerPayout: null,
      underlyingPrice: null
    ): EventFilter;

    OrdersCancelledUpTo(timestamp: null, maker: string | null): EventFilter;

    OwnershipTransferCompleted(
      previousOwner: string | null,
      newOwner: string | null
    ): EventFilter;

    OwnershipTransferStarted(
      previousOwner: string | null,
      pendingOwner: string | null
    ): EventFilter;

    ProtocolFeeChanged(previousFee: null, newFee: null): EventFilter;
  };

  estimateGas: {
    CHAIN_TOKEN_ADDRESS(overrides?: CallOverrides): Promise<BigNumber>;

    "CHAIN_TOKEN_ADDRESS()"(overrides?: CallOverrides): Promise<BigNumber>;

    DOMAIN_SEPARATOR(overrides?: CallOverrides): Promise<BigNumber>;

    "DOMAIN_SEPARATOR()"(overrides?: CallOverrides): Promise<BigNumber>;

    EIP712_DOMAIN_TYPEHASH(overrides?: CallOverrides): Promise<BigNumber>;

    "EIP712_DOMAIN_TYPEHASH()"(overrides?: CallOverrides): Promise<BigNumber>;

    META_ORDER_PROTOCOL_TYPEHASH(overrides?: CallOverrides): Promise<BigNumber>;

    "META_ORDER_PROTOCOL_TYPEHASH()"(
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    OPTION_ATTRIBUTES_TYPEHASH(overrides?: CallOverrides): Promise<BigNumber>;

    "OPTION_ATTRIBUTES_TYPEHASH()"(
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    ORDER_TRACKING_TYPEHASH(overrides?: CallOverrides): Promise<BigNumber>;

    "ORDER_TRACKING_TYPEHASH()"(overrides?: CallOverrides): Promise<BigNumber>;

    ROLLA_ORDER_PROTOCOL_TYPEHASH(
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    "ROLLA_ORDER_PROTOCOL_TYPEHASH()"(
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    SIGNATURE_TYPEHASH(overrides?: CallOverrides): Promise<BigNumber>;

    "SIGNATURE_TYPEHASH()"(overrides?: CallOverrides): Promise<BigNumber>;

    acceptOwnership(overrides?: Overrides): Promise<BigNumber>;

    "acceptOwnership()"(overrides?: Overrides): Promise<BigNumber>;

    cancelOrder(
      order: {
        orderCreationTimestamp: BigNumberish;
        orderExpirationTimestamp: BigNumberish;
        makerAsset: string;
        optionAttributes: {
          underlyingAsset: string;
          oracle: string;
          expiryTime: BigNumberish;
          isCall: boolean;
          strikePrice: BigNumberish;
        };
        maker: string;
        taker: string;
        allowedSender: string;
        makingAmount: BigNumberish;
        takingAmount: BigNumberish;
        whitelist: string;
        orderTracking: {
          integrator: string;
          integratorPercentage: BigNumberish;
          orderTag: BytesLike;
        };
        takerIsSigner: boolean;
      },
      overrides?: Overrides
    ): Promise<BigNumber>;

    "cancelOrder((uint64,uint64,address,(address,address,uint88,bool,uint256),address,address,address,uint256,uint256,address,(address,uint256,bytes32),bool))"(
      order: {
        orderCreationTimestamp: BigNumberish;
        orderExpirationTimestamp: BigNumberish;
        makerAsset: string;
        optionAttributes: {
          underlyingAsset: string;
          oracle: string;
          expiryTime: BigNumberish;
          isCall: boolean;
          strikePrice: BigNumberish;
        };
        maker: string;
        taker: string;
        allowedSender: string;
        makingAmount: BigNumberish;
        takingAmount: BigNumberish;
        whitelist: string;
        orderTracking: {
          integrator: string;
          integratorPercentage: BigNumberish;
          orderTag: BytesLike;
        };
        takerIsSigner: boolean;
      },
      overrides?: Overrides
    ): Promise<BigNumber>;

    cancelOrdersUpTo(
      timestamp: BigNumberish,
      overrides?: Overrides
    ): Promise<BigNumber>;

    "cancelOrdersUpTo(uint64)"(
      timestamp: BigNumberish,
      overrides?: Overrides
    ): Promise<BigNumber>;

    chainTokenWrapper(overrides?: CallOverrides): Promise<BigNumber>;

    "chainTokenWrapper()"(overrides?: CallOverrides): Promise<BigNumber>;

    collateralToken(overrides?: CallOverrides): Promise<BigNumber>;

    "collateralToken()"(overrides?: CallOverrides): Promise<BigNumber>;

    controller(overrides?: CallOverrides): Promise<BigNumber>;

    "controller()"(overrides?: CallOverrides): Promise<BigNumber>;

    executeMetaTransaction(
      metaOrder: {
        functionType: BigNumberish;
        nonce: BigNumberish;
        deadline: BigNumberish;
        from: string;
        order: {
          orderCreationTimestamp: BigNumberish;
          orderExpirationTimestamp: BigNumberish;
          makerAsset: string;
          optionAttributes: {
            underlyingAsset: string;
            oracle: string;
            expiryTime: BigNumberish;
            isCall: boolean;
            strikePrice: BigNumberish;
          };
          maker: string;
          taker: string;
          allowedSender: string;
          makingAmount: BigNumberish;
          takingAmount: BigNumberish;
          whitelist: string;
          orderTracking: {
            integrator: string;
            integratorPercentage: BigNumberish;
            orderTag: BytesLike;
          };
          takerIsSigner: boolean;
        };
        signature: { signatureType: BigNumberish; signatureData: BytesLike };
        permit: BytesLike;
      },
      r: BytesLike,
      s: BytesLike,
      v: BigNumberish,
      signatureType: BigNumberish,
      overrides?: PayableOverrides
    ): Promise<BigNumber>;

    "executeMetaTransaction((uint8,uint256,uint256,address,(uint64,uint64,address,(address,address,uint88,bool,uint256),address,address,address,uint256,uint256,address,(address,uint256,bytes32),bool),(uint8,bytes),bytes),bytes32,bytes32,uint8,uint8)"(
      metaOrder: {
        functionType: BigNumberish;
        nonce: BigNumberish;
        deadline: BigNumberish;
        from: string;
        order: {
          orderCreationTimestamp: BigNumberish;
          orderExpirationTimestamp: BigNumberish;
          makerAsset: string;
          optionAttributes: {
            underlyingAsset: string;
            oracle: string;
            expiryTime: BigNumberish;
            isCall: boolean;
            strikePrice: BigNumberish;
          };
          maker: string;
          taker: string;
          allowedSender: string;
          makingAmount: BigNumberish;
          takingAmount: BigNumberish;
          whitelist: string;
          orderTracking: {
            integrator: string;
            integratorPercentage: BigNumberish;
            orderTag: BytesLike;
          };
          takerIsSigner: boolean;
        };
        signature: { signatureType: BigNumberish; signatureData: BytesLike };
        permit: BytesLike;
      },
      r: BytesLike,
      s: BytesLike,
      v: BigNumberish,
      signatureType: BigNumberish,
      overrides?: PayableOverrides
    ): Promise<BigNumber>;

    fillOrder(
      order: {
        orderCreationTimestamp: BigNumberish;
        orderExpirationTimestamp: BigNumberish;
        makerAsset: string;
        optionAttributes: {
          underlyingAsset: string;
          oracle: string;
          expiryTime: BigNumberish;
          isCall: boolean;
          strikePrice: BigNumberish;
        };
        maker: string;
        taker: string;
        allowedSender: string;
        makingAmount: BigNumberish;
        takingAmount: BigNumberish;
        whitelist: string;
        orderTracking: {
          integrator: string;
          integratorPercentage: BigNumberish;
          orderTag: BytesLike;
        };
        takerIsSigner: boolean;
      },
      signature: { signatureType: BigNumberish; signatureData: BytesLike },
      overrides?: Overrides
    ): Promise<BigNumber>;

    "fillOrder((uint64,uint64,address,(address,address,uint88,bool,uint256),address,address,address,uint256,uint256,address,(address,uint256,bytes32),bool),(uint8,bytes))"(
      order: {
        orderCreationTimestamp: BigNumberish;
        orderExpirationTimestamp: BigNumberish;
        makerAsset: string;
        optionAttributes: {
          underlyingAsset: string;
          oracle: string;
          expiryTime: BigNumberish;
          isCall: boolean;
          strikePrice: BigNumberish;
        };
        maker: string;
        taker: string;
        allowedSender: string;
        makingAmount: BigNumberish;
        takingAmount: BigNumberish;
        whitelist: string;
        orderTracking: {
          integrator: string;
          integratorPercentage: BigNumberish;
          orderTag: BytesLike;
        };
        takerIsSigner: boolean;
      },
      signature: { signatureType: BigNumberish; signatureData: BytesLike },
      overrides?: Overrides
    ): Promise<BigNumber>;

    fillOrderWithChainToken(
      order: {
        orderCreationTimestamp: BigNumberish;
        orderExpirationTimestamp: BigNumberish;
        makerAsset: string;
        optionAttributes: {
          underlyingAsset: string;
          oracle: string;
          expiryTime: BigNumberish;
          isCall: boolean;
          strikePrice: BigNumberish;
        };
        maker: string;
        taker: string;
        allowedSender: string;
        makingAmount: BigNumberish;
        takingAmount: BigNumberish;
        whitelist: string;
        orderTracking: {
          integrator: string;
          integratorPercentage: BigNumberish;
          orderTag: BytesLike;
        };
        takerIsSigner: boolean;
      },
      signature: { signatureType: BigNumberish; signatureData: BytesLike },
      overrides?: PayableOverrides
    ): Promise<BigNumber>;

    "fillOrderWithChainToken((uint64,uint64,address,(address,address,uint88,bool,uint256),address,address,address,uint256,uint256,address,(address,uint256,bytes32),bool),(uint8,bytes))"(
      order: {
        orderCreationTimestamp: BigNumberish;
        orderExpirationTimestamp: BigNumberish;
        makerAsset: string;
        optionAttributes: {
          underlyingAsset: string;
          oracle: string;
          expiryTime: BigNumberish;
          isCall: boolean;
          strikePrice: BigNumberish;
        };
        maker: string;
        taker: string;
        allowedSender: string;
        makingAmount: BigNumberish;
        takingAmount: BigNumberish;
        whitelist: string;
        orderTracking: {
          integrator: string;
          integratorPercentage: BigNumberish;
          orderTag: BytesLike;
        };
        takerIsSigner: boolean;
      },
      signature: { signatureType: BigNumberish; signatureData: BytesLike },
      overrides?: PayableOverrides
    ): Promise<BigNumber>;

    fillOrderWithPermit(
      order: {
        orderCreationTimestamp: BigNumberish;
        orderExpirationTimestamp: BigNumberish;
        makerAsset: string;
        optionAttributes: {
          underlyingAsset: string;
          oracle: string;
          expiryTime: BigNumberish;
          isCall: boolean;
          strikePrice: BigNumberish;
        };
        maker: string;
        taker: string;
        allowedSender: string;
        makingAmount: BigNumberish;
        takingAmount: BigNumberish;
        whitelist: string;
        orderTracking: {
          integrator: string;
          integratorPercentage: BigNumberish;
          orderTag: BytesLike;
        };
        takerIsSigner: boolean;
      },
      signature: { signatureType: BigNumberish; signatureData: BytesLike },
      permit: BytesLike,
      overrides?: Overrides
    ): Promise<BigNumber>;

    "fillOrderWithPermit((uint64,uint64,address,(address,address,uint88,bool,uint256),address,address,address,uint256,uint256,address,(address,uint256,bytes32),bool),(uint8,bytes),bytes)"(
      order: {
        orderCreationTimestamp: BigNumberish;
        orderExpirationTimestamp: BigNumberish;
        makerAsset: string;
        optionAttributes: {
          underlyingAsset: string;
          oracle: string;
          expiryTime: BigNumberish;
          isCall: boolean;
          strikePrice: BigNumberish;
        };
        maker: string;
        taker: string;
        allowedSender: string;
        makingAmount: BigNumberish;
        takingAmount: BigNumberish;
        whitelist: string;
        orderTracking: {
          integrator: string;
          integratorPercentage: BigNumberish;
          orderTag: BytesLike;
        };
        takerIsSigner: boolean;
      },
      signature: { signatureType: BigNumberish; signatureData: BytesLike },
      permit: BytesLike,
      overrides?: Overrides
    ): Promise<BigNumber>;

    getNonce(user: string, overrides?: CallOverrides): Promise<BigNumber>;

    "getNonce(address)"(
      user: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    hashMetaOrder(
      metaOrder: {
        functionType: BigNumberish;
        nonce: BigNumberish;
        deadline: BigNumberish;
        from: string;
        order: {
          orderCreationTimestamp: BigNumberish;
          orderExpirationTimestamp: BigNumberish;
          makerAsset: string;
          optionAttributes: {
            underlyingAsset: string;
            oracle: string;
            expiryTime: BigNumberish;
            isCall: boolean;
            strikePrice: BigNumberish;
          };
          maker: string;
          taker: string;
          allowedSender: string;
          makingAmount: BigNumberish;
          takingAmount: BigNumberish;
          whitelist: string;
          orderTracking: {
            integrator: string;
            integratorPercentage: BigNumberish;
            orderTag: BytesLike;
          };
          takerIsSigner: boolean;
        };
        signature: { signatureType: BigNumberish; signatureData: BytesLike };
        permit: BytesLike;
      },
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    "hashMetaOrder((uint8,uint256,uint256,address,(uint64,uint64,address,(address,address,uint88,bool,uint256),address,address,address,uint256,uint256,address,(address,uint256,bytes32),bool),(uint8,bytes),bytes))"(
      metaOrder: {
        functionType: BigNumberish;
        nonce: BigNumberish;
        deadline: BigNumberish;
        from: string;
        order: {
          orderCreationTimestamp: BigNumberish;
          orderExpirationTimestamp: BigNumberish;
          makerAsset: string;
          optionAttributes: {
            underlyingAsset: string;
            oracle: string;
            expiryTime: BigNumberish;
            isCall: boolean;
            strikePrice: BigNumberish;
          };
          maker: string;
          taker: string;
          allowedSender: string;
          makingAmount: BigNumberish;
          takingAmount: BigNumberish;
          whitelist: string;
          orderTracking: {
            integrator: string;
            integratorPercentage: BigNumberish;
            orderTag: BytesLike;
          };
          takerIsSigner: boolean;
        };
        signature: { signatureType: BigNumberish; signatureData: BytesLike };
        permit: BytesLike;
      },
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    hashOrder(
      order: {
        orderCreationTimestamp: BigNumberish;
        orderExpirationTimestamp: BigNumberish;
        makerAsset: string;
        optionAttributes: {
          underlyingAsset: string;
          oracle: string;
          expiryTime: BigNumberish;
          isCall: boolean;
          strikePrice: BigNumberish;
        };
        maker: string;
        taker: string;
        allowedSender: string;
        makingAmount: BigNumberish;
        takingAmount: BigNumberish;
        whitelist: string;
        orderTracking: {
          integrator: string;
          integratorPercentage: BigNumberish;
          orderTag: BytesLike;
        };
        takerIsSigner: boolean;
      },
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    "hashOrder((uint64,uint64,address,(address,address,uint88,bool,uint256),address,address,address,uint256,uint256,address,(address,uint256,bytes32),bool))"(
      order: {
        orderCreationTimestamp: BigNumberish;
        orderExpirationTimestamp: BigNumberish;
        makerAsset: string;
        optionAttributes: {
          underlyingAsset: string;
          oracle: string;
          expiryTime: BigNumberish;
          isCall: boolean;
          strikePrice: BigNumberish;
        };
        maker: string;
        taker: string;
        allowedSender: string;
        makingAmount: BigNumberish;
        takingAmount: BigNumberish;
        whitelist: string;
        orderTracking: {
          integrator: string;
          integratorPercentage: BigNumberish;
          orderTag: BytesLike;
        };
        takerIsSigner: boolean;
      },
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    isInvalidatedOrder(
      arg0: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    "isInvalidatedOrder(bytes32)"(
      arg0: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    makerCancelTime(
      arg0: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    "makerCancelTime(address)"(
      arg0: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    name(overrides?: CallOverrides): Promise<BigNumber>;

    "name()"(overrides?: CallOverrides): Promise<BigNumber>;

    onERC1155Received(
      arg0: string,
      arg1: string,
      arg2: BigNumberish,
      arg3: BigNumberish,
      arg4: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    "onERC1155Received(address,address,uint256,uint256,bytes)"(
      arg0: string,
      arg1: string,
      arg2: BigNumberish,
      arg3: BigNumberish,
      arg4: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    optionsFactory(overrides?: CallOverrides): Promise<BigNumber>;

    "optionsFactory()"(overrides?: CallOverrides): Promise<BigNumber>;

    owner(overrides?: CallOverrides): Promise<BigNumber>;

    "owner()"(overrides?: CallOverrides): Promise<BigNumber>;

    pendingOwner(overrides?: CallOverrides): Promise<BigNumber>;

    "pendingOwner()"(overrides?: CallOverrides): Promise<BigNumber>;

    protocolFee(overrides?: CallOverrides): Promise<BigNumber>;

    "protocolFee()"(overrides?: CallOverrides): Promise<BigNumber>;

    renounceOwnership(overrides?: Overrides): Promise<BigNumber>;

    "renounceOwnership()"(overrides?: Overrides): Promise<BigNumber>;

    sendFees(
      _to: string,
      _token: string,
      _amount: BigNumberish,
      overrides?: Overrides
    ): Promise<BigNumber>;

    "sendFees(address,address,uint256)"(
      _to: string,
      _token: string,
      _amount: BigNumberish,
      overrides?: Overrides
    ): Promise<BigNumber>;

    setProtocolFee(
      _protocolFee: BigNumberish,
      overrides?: Overrides
    ): Promise<BigNumber>;

    "setProtocolFee(uint256)"(
      _protocolFee: BigNumberish,
      overrides?: Overrides
    ): Promise<BigNumber>;

    transferOwnership(
      newOwner: string,
      overrides?: Overrides
    ): Promise<BigNumber>;

    "transferOwnership(address)"(
      newOwner: string,
      overrides?: Overrides
    ): Promise<BigNumber>;

    version(overrides?: CallOverrides): Promise<BigNumber>;

    "version()"(overrides?: CallOverrides): Promise<BigNumber>;
  };

  populateTransaction: {
    CHAIN_TOKEN_ADDRESS(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    "CHAIN_TOKEN_ADDRESS()"(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    DOMAIN_SEPARATOR(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    "DOMAIN_SEPARATOR()"(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    EIP712_DOMAIN_TYPEHASH(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    "EIP712_DOMAIN_TYPEHASH()"(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    META_ORDER_PROTOCOL_TYPEHASH(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    "META_ORDER_PROTOCOL_TYPEHASH()"(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    OPTION_ATTRIBUTES_TYPEHASH(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    "OPTION_ATTRIBUTES_TYPEHASH()"(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    ORDER_TRACKING_TYPEHASH(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    "ORDER_TRACKING_TYPEHASH()"(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    ROLLA_ORDER_PROTOCOL_TYPEHASH(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    "ROLLA_ORDER_PROTOCOL_TYPEHASH()"(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    SIGNATURE_TYPEHASH(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    "SIGNATURE_TYPEHASH()"(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    acceptOwnership(overrides?: Overrides): Promise<PopulatedTransaction>;

    "acceptOwnership()"(overrides?: Overrides): Promise<PopulatedTransaction>;

    cancelOrder(
      order: {
        orderCreationTimestamp: BigNumberish;
        orderExpirationTimestamp: BigNumberish;
        makerAsset: string;
        optionAttributes: {
          underlyingAsset: string;
          oracle: string;
          expiryTime: BigNumberish;
          isCall: boolean;
          strikePrice: BigNumberish;
        };
        maker: string;
        taker: string;
        allowedSender: string;
        makingAmount: BigNumberish;
        takingAmount: BigNumberish;
        whitelist: string;
        orderTracking: {
          integrator: string;
          integratorPercentage: BigNumberish;
          orderTag: BytesLike;
        };
        takerIsSigner: boolean;
      },
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    "cancelOrder((uint64,uint64,address,(address,address,uint88,bool,uint256),address,address,address,uint256,uint256,address,(address,uint256,bytes32),bool))"(
      order: {
        orderCreationTimestamp: BigNumberish;
        orderExpirationTimestamp: BigNumberish;
        makerAsset: string;
        optionAttributes: {
          underlyingAsset: string;
          oracle: string;
          expiryTime: BigNumberish;
          isCall: boolean;
          strikePrice: BigNumberish;
        };
        maker: string;
        taker: string;
        allowedSender: string;
        makingAmount: BigNumberish;
        takingAmount: BigNumberish;
        whitelist: string;
        orderTracking: {
          integrator: string;
          integratorPercentage: BigNumberish;
          orderTag: BytesLike;
        };
        takerIsSigner: boolean;
      },
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    cancelOrdersUpTo(
      timestamp: BigNumberish,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    "cancelOrdersUpTo(uint64)"(
      timestamp: BigNumberish,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    chainTokenWrapper(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    "chainTokenWrapper()"(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    collateralToken(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    "collateralToken()"(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    controller(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    "controller()"(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    executeMetaTransaction(
      metaOrder: {
        functionType: BigNumberish;
        nonce: BigNumberish;
        deadline: BigNumberish;
        from: string;
        order: {
          orderCreationTimestamp: BigNumberish;
          orderExpirationTimestamp: BigNumberish;
          makerAsset: string;
          optionAttributes: {
            underlyingAsset: string;
            oracle: string;
            expiryTime: BigNumberish;
            isCall: boolean;
            strikePrice: BigNumberish;
          };
          maker: string;
          taker: string;
          allowedSender: string;
          makingAmount: BigNumberish;
          takingAmount: BigNumberish;
          whitelist: string;
          orderTracking: {
            integrator: string;
            integratorPercentage: BigNumberish;
            orderTag: BytesLike;
          };
          takerIsSigner: boolean;
        };
        signature: { signatureType: BigNumberish; signatureData: BytesLike };
        permit: BytesLike;
      },
      r: BytesLike,
      s: BytesLike,
      v: BigNumberish,
      signatureType: BigNumberish,
      overrides?: PayableOverrides
    ): Promise<PopulatedTransaction>;

    "executeMetaTransaction((uint8,uint256,uint256,address,(uint64,uint64,address,(address,address,uint88,bool,uint256),address,address,address,uint256,uint256,address,(address,uint256,bytes32),bool),(uint8,bytes),bytes),bytes32,bytes32,uint8,uint8)"(
      metaOrder: {
        functionType: BigNumberish;
        nonce: BigNumberish;
        deadline: BigNumberish;
        from: string;
        order: {
          orderCreationTimestamp: BigNumberish;
          orderExpirationTimestamp: BigNumberish;
          makerAsset: string;
          optionAttributes: {
            underlyingAsset: string;
            oracle: string;
            expiryTime: BigNumberish;
            isCall: boolean;
            strikePrice: BigNumberish;
          };
          maker: string;
          taker: string;
          allowedSender: string;
          makingAmount: BigNumberish;
          takingAmount: BigNumberish;
          whitelist: string;
          orderTracking: {
            integrator: string;
            integratorPercentage: BigNumberish;
            orderTag: BytesLike;
          };
          takerIsSigner: boolean;
        };
        signature: { signatureType: BigNumberish; signatureData: BytesLike };
        permit: BytesLike;
      },
      r: BytesLike,
      s: BytesLike,
      v: BigNumberish,
      signatureType: BigNumberish,
      overrides?: PayableOverrides
    ): Promise<PopulatedTransaction>;

    fillOrder(
      order: {
        orderCreationTimestamp: BigNumberish;
        orderExpirationTimestamp: BigNumberish;
        makerAsset: string;
        optionAttributes: {
          underlyingAsset: string;
          oracle: string;
          expiryTime: BigNumberish;
          isCall: boolean;
          strikePrice: BigNumberish;
        };
        maker: string;
        taker: string;
        allowedSender: string;
        makingAmount: BigNumberish;
        takingAmount: BigNumberish;
        whitelist: string;
        orderTracking: {
          integrator: string;
          integratorPercentage: BigNumberish;
          orderTag: BytesLike;
        };
        takerIsSigner: boolean;
      },
      signature: { signatureType: BigNumberish; signatureData: BytesLike },
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    "fillOrder((uint64,uint64,address,(address,address,uint88,bool,uint256),address,address,address,uint256,uint256,address,(address,uint256,bytes32),bool),(uint8,bytes))"(
      order: {
        orderCreationTimestamp: BigNumberish;
        orderExpirationTimestamp: BigNumberish;
        makerAsset: string;
        optionAttributes: {
          underlyingAsset: string;
          oracle: string;
          expiryTime: BigNumberish;
          isCall: boolean;
          strikePrice: BigNumberish;
        };
        maker: string;
        taker: string;
        allowedSender: string;
        makingAmount: BigNumberish;
        takingAmount: BigNumberish;
        whitelist: string;
        orderTracking: {
          integrator: string;
          integratorPercentage: BigNumberish;
          orderTag: BytesLike;
        };
        takerIsSigner: boolean;
      },
      signature: { signatureType: BigNumberish; signatureData: BytesLike },
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    fillOrderWithChainToken(
      order: {
        orderCreationTimestamp: BigNumberish;
        orderExpirationTimestamp: BigNumberish;
        makerAsset: string;
        optionAttributes: {
          underlyingAsset: string;
          oracle: string;
          expiryTime: BigNumberish;
          isCall: boolean;
          strikePrice: BigNumberish;
        };
        maker: string;
        taker: string;
        allowedSender: string;
        makingAmount: BigNumberish;
        takingAmount: BigNumberish;
        whitelist: string;
        orderTracking: {
          integrator: string;
          integratorPercentage: BigNumberish;
          orderTag: BytesLike;
        };
        takerIsSigner: boolean;
      },
      signature: { signatureType: BigNumberish; signatureData: BytesLike },
      overrides?: PayableOverrides
    ): Promise<PopulatedTransaction>;

    "fillOrderWithChainToken((uint64,uint64,address,(address,address,uint88,bool,uint256),address,address,address,uint256,uint256,address,(address,uint256,bytes32),bool),(uint8,bytes))"(
      order: {
        orderCreationTimestamp: BigNumberish;
        orderExpirationTimestamp: BigNumberish;
        makerAsset: string;
        optionAttributes: {
          underlyingAsset: string;
          oracle: string;
          expiryTime: BigNumberish;
          isCall: boolean;
          strikePrice: BigNumberish;
        };
        maker: string;
        taker: string;
        allowedSender: string;
        makingAmount: BigNumberish;
        takingAmount: BigNumberish;
        whitelist: string;
        orderTracking: {
          integrator: string;
          integratorPercentage: BigNumberish;
          orderTag: BytesLike;
        };
        takerIsSigner: boolean;
      },
      signature: { signatureType: BigNumberish; signatureData: BytesLike },
      overrides?: PayableOverrides
    ): Promise<PopulatedTransaction>;

    fillOrderWithPermit(
      order: {
        orderCreationTimestamp: BigNumberish;
        orderExpirationTimestamp: BigNumberish;
        makerAsset: string;
        optionAttributes: {
          underlyingAsset: string;
          oracle: string;
          expiryTime: BigNumberish;
          isCall: boolean;
          strikePrice: BigNumberish;
        };
        maker: string;
        taker: string;
        allowedSender: string;
        makingAmount: BigNumberish;
        takingAmount: BigNumberish;
        whitelist: string;
        orderTracking: {
          integrator: string;
          integratorPercentage: BigNumberish;
          orderTag: BytesLike;
        };
        takerIsSigner: boolean;
      },
      signature: { signatureType: BigNumberish; signatureData: BytesLike },
      permit: BytesLike,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    "fillOrderWithPermit((uint64,uint64,address,(address,address,uint88,bool,uint256),address,address,address,uint256,uint256,address,(address,uint256,bytes32),bool),(uint8,bytes),bytes)"(
      order: {
        orderCreationTimestamp: BigNumberish;
        orderExpirationTimestamp: BigNumberish;
        makerAsset: string;
        optionAttributes: {
          underlyingAsset: string;
          oracle: string;
          expiryTime: BigNumberish;
          isCall: boolean;
          strikePrice: BigNumberish;
        };
        maker: string;
        taker: string;
        allowedSender: string;
        makingAmount: BigNumberish;
        takingAmount: BigNumberish;
        whitelist: string;
        orderTracking: {
          integrator: string;
          integratorPercentage: BigNumberish;
          orderTag: BytesLike;
        };
        takerIsSigner: boolean;
      },
      signature: { signatureType: BigNumberish; signatureData: BytesLike },
      permit: BytesLike,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    getNonce(
      user: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    "getNonce(address)"(
      user: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    hashMetaOrder(
      metaOrder: {
        functionType: BigNumberish;
        nonce: BigNumberish;
        deadline: BigNumberish;
        from: string;
        order: {
          orderCreationTimestamp: BigNumberish;
          orderExpirationTimestamp: BigNumberish;
          makerAsset: string;
          optionAttributes: {
            underlyingAsset: string;
            oracle: string;
            expiryTime: BigNumberish;
            isCall: boolean;
            strikePrice: BigNumberish;
          };
          maker: string;
          taker: string;
          allowedSender: string;
          makingAmount: BigNumberish;
          takingAmount: BigNumberish;
          whitelist: string;
          orderTracking: {
            integrator: string;
            integratorPercentage: BigNumberish;
            orderTag: BytesLike;
          };
          takerIsSigner: boolean;
        };
        signature: { signatureType: BigNumberish; signatureData: BytesLike };
        permit: BytesLike;
      },
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    "hashMetaOrder((uint8,uint256,uint256,address,(uint64,uint64,address,(address,address,uint88,bool,uint256),address,address,address,uint256,uint256,address,(address,uint256,bytes32),bool),(uint8,bytes),bytes))"(
      metaOrder: {
        functionType: BigNumberish;
        nonce: BigNumberish;
        deadline: BigNumberish;
        from: string;
        order: {
          orderCreationTimestamp: BigNumberish;
          orderExpirationTimestamp: BigNumberish;
          makerAsset: string;
          optionAttributes: {
            underlyingAsset: string;
            oracle: string;
            expiryTime: BigNumberish;
            isCall: boolean;
            strikePrice: BigNumberish;
          };
          maker: string;
          taker: string;
          allowedSender: string;
          makingAmount: BigNumberish;
          takingAmount: BigNumberish;
          whitelist: string;
          orderTracking: {
            integrator: string;
            integratorPercentage: BigNumberish;
            orderTag: BytesLike;
          };
          takerIsSigner: boolean;
        };
        signature: { signatureType: BigNumberish; signatureData: BytesLike };
        permit: BytesLike;
      },
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    hashOrder(
      order: {
        orderCreationTimestamp: BigNumberish;
        orderExpirationTimestamp: BigNumberish;
        makerAsset: string;
        optionAttributes: {
          underlyingAsset: string;
          oracle: string;
          expiryTime: BigNumberish;
          isCall: boolean;
          strikePrice: BigNumberish;
        };
        maker: string;
        taker: string;
        allowedSender: string;
        makingAmount: BigNumberish;
        takingAmount: BigNumberish;
        whitelist: string;
        orderTracking: {
          integrator: string;
          integratorPercentage: BigNumberish;
          orderTag: BytesLike;
        };
        takerIsSigner: boolean;
      },
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    "hashOrder((uint64,uint64,address,(address,address,uint88,bool,uint256),address,address,address,uint256,uint256,address,(address,uint256,bytes32),bool))"(
      order: {
        orderCreationTimestamp: BigNumberish;
        orderExpirationTimestamp: BigNumberish;
        makerAsset: string;
        optionAttributes: {
          underlyingAsset: string;
          oracle: string;
          expiryTime: BigNumberish;
          isCall: boolean;
          strikePrice: BigNumberish;
        };
        maker: string;
        taker: string;
        allowedSender: string;
        makingAmount: BigNumberish;
        takingAmount: BigNumberish;
        whitelist: string;
        orderTracking: {
          integrator: string;
          integratorPercentage: BigNumberish;
          orderTag: BytesLike;
        };
        takerIsSigner: boolean;
      },
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    isInvalidatedOrder(
      arg0: BytesLike,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    "isInvalidatedOrder(bytes32)"(
      arg0: BytesLike,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    makerCancelTime(
      arg0: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    "makerCancelTime(address)"(
      arg0: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    name(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    "name()"(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    onERC1155Received(
      arg0: string,
      arg1: string,
      arg2: BigNumberish,
      arg3: BigNumberish,
      arg4: BytesLike,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    "onERC1155Received(address,address,uint256,uint256,bytes)"(
      arg0: string,
      arg1: string,
      arg2: BigNumberish,
      arg3: BigNumberish,
      arg4: BytesLike,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    optionsFactory(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    "optionsFactory()"(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    owner(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    "owner()"(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    pendingOwner(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    "pendingOwner()"(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    protocolFee(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    "protocolFee()"(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    renounceOwnership(overrides?: Overrides): Promise<PopulatedTransaction>;

    "renounceOwnership()"(overrides?: Overrides): Promise<PopulatedTransaction>;

    sendFees(
      _to: string,
      _token: string,
      _amount: BigNumberish,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    "sendFees(address,address,uint256)"(
      _to: string,
      _token: string,
      _amount: BigNumberish,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    setProtocolFee(
      _protocolFee: BigNumberish,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    "setProtocolFee(uint256)"(
      _protocolFee: BigNumberish,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    transferOwnership(
      newOwner: string,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    "transferOwnership(address)"(
      newOwner: string,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    version(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    "version()"(overrides?: CallOverrides): Promise<PopulatedTransaction>;
  };
}
