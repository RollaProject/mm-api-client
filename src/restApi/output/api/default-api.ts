/* tslint:disable */
/* eslint-disable */
/**
 * Rolla Yield API - Market Maker
 * Rolla Yield API provides a RESTful API for fetching assets, options and quotes
 *
 * The version of the OpenAPI document: 1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import { Configuration } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from '../common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
// @ts-ignore
import { AssetDto } from '../interfaces';
// @ts-ignore
import { ConfigDto } from '../interfaces';
// @ts-ignore
import { ErrorResponseDto } from '../interfaces';
// @ts-ignore
import { GasDetailsDto } from '../interfaces';
// @ts-ignore
import { LastLookResponseDto } from '../interfaces';
// @ts-ignore
import { LastLookResponseWithOrderSignatureDto } from '../interfaces';
// @ts-ignore
import { MakerOverviewDto } from '../interfaces';
// @ts-ignore
import { MarketMakerQuoteRequestDto } from '../interfaces';
// @ts-ignore
import { MarketMakerQuoteResponseDto } from '../interfaces';
// @ts-ignore
import { OptionDto } from '../interfaces';
// @ts-ignore
import { OptionMarketMakerControllerGetPriceRegistryEvents400Response } from '../interfaces';
// @ts-ignore
import { OraclePricesDto } from '../interfaces';
// @ts-ignore
import { PostMetaTransactionResponseDto } from '../interfaces';
// @ts-ignore
import { PriceStoredDto } from '../interfaces';
// @ts-ignore
import { QuoteDto } from '../interfaces';
// @ts-ignore
import { QuoteRequestDto } from '../interfaces';
// @ts-ignore
import { QuoteResponseReplyDto } from '../interfaces';
// @ts-ignore
import { QuoteWithMetaDataDto } from '../interfaces';
// @ts-ignore
import { SetMakerActiveDto } from '../interfaces';
// @ts-ignore
import { SignedMetaTransactionDto } from '../interfaces';
// @ts-ignore
import { StatsDto } from '../interfaces';
// @ts-ignore
import { SummaryDto } from '../interfaces';
// @ts-ignore
import { SupportedUnderlyingAssetsDto } from '../interfaces';
// @ts-ignore
import { SupportsCustomOptionsDto } from '../interfaces';
// @ts-ignore
import { TradeDto } from '../interfaces';
/**
 * DefaultApi - axios parameter creator
 * @export
 */
export const DefaultApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _function: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/quotes/temp`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication custom required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Controls whether the market maker will be asked to provide quotes
         * @param {SetMakerActiveDto} setMakerActiveDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeMarketMakerVisibility: async (setMakerActiveDto: SetMakerActiveDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'setMakerActiveDto' is not null or undefined
            assertParamExists('changeMarketMakerVisibility', 'setMakerActiveDto', setMakerActiveDto)
            const localVarPath = `/v1/marketmaker/isActive`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication custom required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(setMakerActiveDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieves a list of all active options (non-expired)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllActiveOptions: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/options/active`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieves a list of all supported assets and their price
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllAssets: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/assets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets prices of all assets
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllPrices: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/prices`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieves the configuration details of the network
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConfig: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/config`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets the latest gas details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGasDetails: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/gas`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get indicative quotes of assets
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIndicativeQuotes: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/quotes/indicative`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInternalConfig: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/config/internal`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieves a list of market maker\'s active quotes. Active means not filled, not cancelled and not expired.
         * @param {string} optionAddress 
         * @param {string} underlyingAddress 
         * @param {string} [fromUniqueEventId] 
         * @param {string} [toUniqueEventId] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMarketMakerActiveQuotes: async (optionAddress: string, underlyingAddress: string, fromUniqueEventId?: string, toUniqueEventId?: string, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'optionAddress' is not null or undefined
            assertParamExists('getMarketMakerActiveQuotes', 'optionAddress', optionAddress)
            // verify required parameter 'underlyingAddress' is not null or undefined
            assertParamExists('getMarketMakerActiveQuotes', 'underlyingAddress', underlyingAddress)
            const localVarPath = `/v1/quotes/active`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication custom required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (optionAddress !== undefined) {
                localVarQueryParameter['optionAddress'] = optionAddress;
            }

            if (underlyingAddress !== undefined) {
                localVarQueryParameter['underlyingAddress'] = underlyingAddress;
            }

            if (fromUniqueEventId !== undefined) {
                localVarQueryParameter['fromUniqueEventId'] = fromUniqueEventId;
            }

            if (toUniqueEventId !== undefined) {
                localVarQueryParameter['toUniqueEventId'] = toUniqueEventId;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieves an overview of the market maker account.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMarketMakerOverview: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/marketmaker/overview`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication custom required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieves a list of market maker\'s trades
         * @param {string} includeTradeTypes 
         * @param {string} optionAddress 
         * @param {string} underlyingAddress 
         * @param {string} [fromUniqueEventId] 
         * @param {string} [toUniqueEventId] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMarketMakerTrades: async (includeTradeTypes: string, optionAddress: string, underlyingAddress: string, fromUniqueEventId?: string, toUniqueEventId?: string, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'includeTradeTypes' is not null or undefined
            assertParamExists('getMarketMakerTrades', 'includeTradeTypes', includeTradeTypes)
            // verify required parameter 'optionAddress' is not null or undefined
            assertParamExists('getMarketMakerTrades', 'optionAddress', optionAddress)
            // verify required parameter 'underlyingAddress' is not null or undefined
            assertParamExists('getMarketMakerTrades', 'underlyingAddress', underlyingAddress)
            const localVarPath = `/v1/trades/market-maker`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication custom required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (includeTradeTypes !== undefined) {
                localVarQueryParameter['includeTradeTypes'] = includeTradeTypes;
            }

            if (optionAddress !== undefined) {
                localVarQueryParameter['optionAddress'] = optionAddress;
            }

            if (underlyingAddress !== undefined) {
                localVarQueryParameter['underlyingAddress'] = underlyingAddress;
            }

            if (fromUniqueEventId !== undefined) {
                localVarQueryParameter['fromUniqueEventId'] = fromUniqueEventId;
            }

            if (toUniqueEventId !== undefined) {
                localVarQueryParameter['toUniqueEventId'] = toUniqueEventId;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Fetch pending meta transactions which should be responded to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMetaTransactions: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/metatransaction/requests`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication custom required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieves an option\'s details by its on-chain address. This will only * return option details if the option with that address has been created on-chain.
         * @param {string} optionAddress 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOption: async (optionAddress: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'optionAddress' is not null or undefined
            assertParamExists('getOption', 'optionAddress', optionAddress)
            const localVarPath = `/v1/options/{optionAddress}`
                .replace(`{${"optionAddress"}}`, encodeURIComponent(String(optionAddress)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication custom required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieves a list of stats entries for given key
         * @param {string} key 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOptionStats: async (key: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'key' is not null or undefined
            assertParamExists('getOptionStats', 'key', key)
            const localVarPath = `/v1/stats/{key}`
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary returns price registry events from Chainlink oracle where the event took place at 8am UTC
         * @param {string} underlyingAssetAddress 
         * @param {string} [fromUniqueEventId] 
         * @param {string} [toUniqueEventId] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPriceRegistryEvents: async (underlyingAssetAddress: string, fromUniqueEventId?: string, toUniqueEventId?: string, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'underlyingAssetAddress' is not null or undefined
            assertParamExists('getPriceRegistryEvents', 'underlyingAssetAddress', underlyingAssetAddress)
            const localVarPath = `/v1/options/settlementPrices/{underlyingAssetAddress}`
                .replace(`{${"underlyingAssetAddress"}}`, encodeURIComponent(String(underlyingAssetAddress)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication custom required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (fromUniqueEventId !== undefined) {
                localVarQueryParameter['fromUniqueEventId'] = fromUniqueEventId;
            }

            if (toUniqueEventId !== undefined) {
                localVarQueryParameter['toUniqueEventId'] = toUniqueEventId;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Request a quote from market makers
         * @param {QuoteRequestDto} quoteRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQuote: async (quoteRequestDto: QuoteRequestDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'quoteRequestDto' is not null or undefined
            assertParamExists('getQuote', 'quoteRequestDto', quoteRequestDto)
            const localVarPath = `/v1/quotes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(quoteRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieves the active quote requests that the authenticated market maker needs to respond to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQuoteRequests: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/quotes/requests`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication custom required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRandomQuote: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/quotes/getRandomQuote`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieves a list of recent trades
         * @param {any} [underlyingAddress] 
         * @param {'CALL' | 'PUT'} [optionType] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecentTrades: async (underlyingAddress?: any, optionType?: 'CALL' | 'PUT', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/trades/recent`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (underlyingAddress !== undefined) {
                localVarQueryParameter['underlyingAddress'] = underlyingAddress;
            }

            if (optionType !== undefined) {
                localVarQueryParameter['optionType'] = optionType;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieves a trade with a given transaction hash
         * @param {string} txHash 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTrade: async (txHash: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'txHash' is not null or undefined
            assertParamExists('getTrade', 'txHash', txHash)
            const localVarPath = `/v1/trades/{txHash}`
                .replace(`{${"txHash"}}`, encodeURIComponent(String(txHash)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieves a market maker\'s positions
         * @param {string} optionAddress 
         * @param {string} underlyingAddress 
         * @param {string} fromOption 
         * @param {string} toOption 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserPositions: async (optionAddress: string, underlyingAddress: string, fromOption: string, toOption: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'optionAddress' is not null or undefined
            assertParamExists('getUserPositions', 'optionAddress', optionAddress)
            // verify required parameter 'underlyingAddress' is not null or undefined
            assertParamExists('getUserPositions', 'underlyingAddress', underlyingAddress)
            // verify required parameter 'fromOption' is not null or undefined
            assertParamExists('getUserPositions', 'fromOption', fromOption)
            // verify required parameter 'toOption' is not null or undefined
            assertParamExists('getUserPositions', 'toOption', toOption)
            const localVarPath = `/v1/positions/options`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication custom required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (optionAddress !== undefined) {
                localVarQueryParameter['optionAddress'] = optionAddress;
            }

            if (underlyingAddress !== undefined) {
                localVarQueryParameter['underlyingAddress'] = underlyingAddress;
            }

            if (fromOption !== undefined) {
                localVarQueryParameter['fromOption'] = fromOption;
            }

            if (toOption !== undefined) {
                localVarQueryParameter['toOption'] = toOption;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieves a list of a user\'s trades
         * @param {any} userAddress 
         * @param {'maker' | 'taker' | 'all'} [includeTradeTypes] Filter trades by trade type
         * @param {string} [optionAddress] 
         * @param {string} [underlyingAddress] 
         * @param {string} [fromUniqueEventId] 
         * @param {string} [toUniqueEventId] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserTrades: async (userAddress: any, includeTradeTypes?: 'maker' | 'taker' | 'all', optionAddress?: string, underlyingAddress?: string, fromUniqueEventId?: string, toUniqueEventId?: string, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userAddress' is not null or undefined
            assertParamExists('getUserTrades', 'userAddress', userAddress)
            const localVarPath = `/v1/trades`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includeTradeTypes !== undefined) {
                localVarQueryParameter['includeTradeTypes'] = includeTradeTypes;
            }

            if (optionAddress !== undefined) {
                localVarQueryParameter['optionAddress'] = optionAddress;
            }

            if (underlyingAddress !== undefined) {
                localVarQueryParameter['underlyingAddress'] = underlyingAddress;
            }

            if (fromUniqueEventId !== undefined) {
                localVarQueryParameter['fromUniqueEventId'] = fromUniqueEventId;
            }

            if (toUniqueEventId !== undefined) {
                localVarQueryParameter['toUniqueEventId'] = toUniqueEventId;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (userAddress !== undefined) {
                localVarQueryParameter['userAddress'] = userAddress;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns a summary including assets, options, indicative quotes, prices, gas and config details.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getYield: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/summary`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Batch respond to meta transaction requests
         * @param {Array<LastLookResponseWithOrderSignatureDto>} lastLookResponseWithOrderSignatureDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postMetaTransactionResponses: async (lastLookResponseWithOrderSignatureDto: Array<LastLookResponseWithOrderSignatureDto>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'lastLookResponseWithOrderSignatureDto' is not null or undefined
            assertParamExists('postMetaTransactionResponses', 'lastLookResponseWithOrderSignatureDto', lastLookResponseWithOrderSignatureDto)
            const localVarPath = `/v1/metatransaction/responses`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication custom required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(lastLookResponseWithOrderSignatureDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Posts quote responses
         * @param {Array<MarketMakerQuoteResponseDto>} marketMakerQuoteResponseDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postQuoteResponses: async (marketMakerQuoteResponseDto: Array<MarketMakerQuoteResponseDto>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'marketMakerQuoteResponseDto' is not null or undefined
            assertParamExists('postQuoteResponses', 'marketMakerQuoteResponseDto', marketMakerQuoteResponseDto)
            const localVarPath = `/v1/quotes/responses`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication custom required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(marketMakerQuoteResponseDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setInternalConfig: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/config/internal`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Sets the assets supported by the market maker
         * @param {SupportedUnderlyingAssetsDto} supportedUnderlyingAssetsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setMarketMakerAssets: async (supportedUnderlyingAssetsDto: SupportedUnderlyingAssetsDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'supportedUnderlyingAssetsDto' is not null or undefined
            assertParamExists('setMarketMakerAssets', 'supportedUnderlyingAssetsDto', supportedUnderlyingAssetsDto)
            const localVarPath = `/v1/marketmaker/supportedAssets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication custom required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(supportedUnderlyingAssetsDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Sets whether custom options are supported by the market maker
         * @param {SupportsCustomOptionsDto} supportsCustomOptionsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setSupportsCustomQuotes: async (supportsCustomOptionsDto: SupportsCustomOptionsDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'supportsCustomOptionsDto' is not null or undefined
            assertParamExists('setSupportsCustomQuotes', 'supportsCustomOptionsDto', supportsCustomOptionsDto)
            const localVarPath = `/v1/marketmaker/supportsCustomOptions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication custom required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(supportsCustomOptionsDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Submit a meta transaction
         * @param {SignedMetaTransactionDto} signedMetaTransactionDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitLastLookRequest: async (signedMetaTransactionDto: SignedMetaTransactionDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'signedMetaTransactionDto' is not null or undefined
            assertParamExists('submitLastLookRequest', 'signedMetaTransactionDto', signedMetaTransactionDto)
            const localVarPath = `/v1/metatransaction`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(signedMetaTransactionDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DefaultApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async _function(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator._function(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Controls whether the market maker will be asked to provide quotes
         * @param {SetMakerActiveDto} setMakerActiveDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async changeMarketMakerVisibility(setMakerActiveDto: SetMakerActiveDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MakerOverviewDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.changeMarketMakerVisibility(setMakerActiveDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Retrieves a list of all active options (non-expired)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllActiveOptions(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<OptionDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllActiveOptions(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Retrieves a list of all supported assets and their price
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllAssets(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AssetDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllAssets(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Gets prices of all assets
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllPrices(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OraclePricesDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllPrices(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Retrieves the configuration details of the network
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getConfig(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConfigDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getConfig(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Gets the latest gas details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGasDetails(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GasDetailsDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGasDetails(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get indicative quotes of assets
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getIndicativeQuotes(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<QuoteDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getIndicativeQuotes(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getInternalConfig(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getInternalConfig(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Retrieves a list of market maker\'s active quotes. Active means not filled, not cancelled and not expired.
         * @param {string} optionAddress 
         * @param {string} underlyingAddress 
         * @param {string} [fromUniqueEventId] 
         * @param {string} [toUniqueEventId] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMarketMakerActiveQuotes(optionAddress: string, underlyingAddress: string, fromUniqueEventId?: string, toUniqueEventId?: string, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<QuoteWithMetaDataDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMarketMakerActiveQuotes(optionAddress, underlyingAddress, fromUniqueEventId, toUniqueEventId, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Retrieves an overview of the market maker account.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMarketMakerOverview(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MakerOverviewDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMarketMakerOverview(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Retrieves a list of market maker\'s trades
         * @param {string} includeTradeTypes 
         * @param {string} optionAddress 
         * @param {string} underlyingAddress 
         * @param {string} [fromUniqueEventId] 
         * @param {string} [toUniqueEventId] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMarketMakerTrades(includeTradeTypes: string, optionAddress: string, underlyingAddress: string, fromUniqueEventId?: string, toUniqueEventId?: string, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TradeDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMarketMakerTrades(includeTradeTypes, optionAddress, underlyingAddress, fromUniqueEventId, toUniqueEventId, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Fetch pending meta transactions which should be responded to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMetaTransactions(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SignedMetaTransactionDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMetaTransactions(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Retrieves an option\'s details by its on-chain address. This will only * return option details if the option with that address has been created on-chain.
         * @param {string} optionAddress 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOption(optionAddress: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OptionDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOption(optionAddress, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Retrieves a list of stats entries for given key
         * @param {string} key 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOptionStats(key: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<StatsDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOptionStats(key, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary returns price registry events from Chainlink oracle where the event took place at 8am UTC
         * @param {string} underlyingAssetAddress 
         * @param {string} [fromUniqueEventId] 
         * @param {string} [toUniqueEventId] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPriceRegistryEvents(underlyingAssetAddress: string, fromUniqueEventId?: string, toUniqueEventId?: string, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PriceStoredDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPriceRegistryEvents(underlyingAssetAddress, fromUniqueEventId, toUniqueEventId, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Request a quote from market makers
         * @param {QuoteRequestDto} quoteRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getQuote(quoteRequestDto: QuoteRequestDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QuoteDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getQuote(quoteRequestDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Retrieves the active quote requests that the authenticated market maker needs to respond to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getQuoteRequests(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<MarketMakerQuoteRequestDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getQuoteRequests(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRandomQuote(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRandomQuote(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Retrieves a list of recent trades
         * @param {any} [underlyingAddress] 
         * @param {'CALL' | 'PUT'} [optionType] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRecentTrades(underlyingAddress?: any, optionType?: 'CALL' | 'PUT', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TradeDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRecentTrades(underlyingAddress, optionType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Retrieves a trade with a given transaction hash
         * @param {string} txHash 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTrade(txHash: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TradeDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTrade(txHash, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Retrieves a market maker\'s positions
         * @param {string} optionAddress 
         * @param {string} underlyingAddress 
         * @param {string} fromOption 
         * @param {string} toOption 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserPositions(optionAddress: string, underlyingAddress: string, fromOption: string, toOption: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TradeDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserPositions(optionAddress, underlyingAddress, fromOption, toOption, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Retrieves a list of a user\'s trades
         * @param {any} userAddress 
         * @param {'maker' | 'taker' | 'all'} [includeTradeTypes] Filter trades by trade type
         * @param {string} [optionAddress] 
         * @param {string} [underlyingAddress] 
         * @param {string} [fromUniqueEventId] 
         * @param {string} [toUniqueEventId] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserTrades(userAddress: any, includeTradeTypes?: 'maker' | 'taker' | 'all', optionAddress?: string, underlyingAddress?: string, fromUniqueEventId?: string, toUniqueEventId?: string, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TradeDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserTrades(userAddress, includeTradeTypes, optionAddress, underlyingAddress, fromUniqueEventId, toUniqueEventId, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Returns a summary including assets, options, indicative quotes, prices, gas and config details.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getYield(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SummaryDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getYield(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Batch respond to meta transaction requests
         * @param {Array<LastLookResponseWithOrderSignatureDto>} lastLookResponseWithOrderSignatureDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postMetaTransactionResponses(lastLookResponseWithOrderSignatureDto: Array<LastLookResponseWithOrderSignatureDto>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PostMetaTransactionResponseDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postMetaTransactionResponses(lastLookResponseWithOrderSignatureDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Posts quote responses
         * @param {Array<MarketMakerQuoteResponseDto>} marketMakerQuoteResponseDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postQuoteResponses(marketMakerQuoteResponseDto: Array<MarketMakerQuoteResponseDto>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<QuoteResponseReplyDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postQuoteResponses(marketMakerQuoteResponseDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setInternalConfig(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setInternalConfig(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Sets the assets supported by the market maker
         * @param {SupportedUnderlyingAssetsDto} supportedUnderlyingAssetsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setMarketMakerAssets(supportedUnderlyingAssetsDto: SupportedUnderlyingAssetsDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MakerOverviewDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setMarketMakerAssets(supportedUnderlyingAssetsDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Sets whether custom options are supported by the market maker
         * @param {SupportsCustomOptionsDto} supportsCustomOptionsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setSupportsCustomQuotes(supportsCustomOptionsDto: SupportsCustomOptionsDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MakerOverviewDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setSupportsCustomQuotes(supportsCustomOptionsDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Submit a meta transaction
         * @param {SignedMetaTransactionDto} signedMetaTransactionDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async submitLastLookRequest(signedMetaTransactionDto: SignedMetaTransactionDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LastLookResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.submitLastLookRequest(signedMetaTransactionDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DefaultApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _function(options?: any): AxiosPromise<void> {
            return localVarFp._function(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Controls whether the market maker will be asked to provide quotes
         * @param {SetMakerActiveDto} setMakerActiveDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeMarketMakerVisibility(setMakerActiveDto: SetMakerActiveDto, options?: any): AxiosPromise<MakerOverviewDto> {
            return localVarFp.changeMarketMakerVisibility(setMakerActiveDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieves a list of all active options (non-expired)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllActiveOptions(options?: any): AxiosPromise<Array<OptionDto>> {
            return localVarFp.getAllActiveOptions(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieves a list of all supported assets and their price
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllAssets(options?: any): AxiosPromise<Array<AssetDto>> {
            return localVarFp.getAllAssets(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets prices of all assets
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllPrices(options?: any): AxiosPromise<OraclePricesDto> {
            return localVarFp.getAllPrices(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieves the configuration details of the network
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConfig(options?: any): AxiosPromise<ConfigDto> {
            return localVarFp.getConfig(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets the latest gas details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGasDetails(options?: any): AxiosPromise<GasDetailsDto> {
            return localVarFp.getGasDetails(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get indicative quotes of assets
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIndicativeQuotes(options?: any): AxiosPromise<Array<QuoteDto>> {
            return localVarFp.getIndicativeQuotes(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInternalConfig(options?: any): AxiosPromise<void> {
            return localVarFp.getInternalConfig(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieves a list of market maker\'s active quotes. Active means not filled, not cancelled and not expired.
         * @param {string} optionAddress 
         * @param {string} underlyingAddress 
         * @param {string} [fromUniqueEventId] 
         * @param {string} [toUniqueEventId] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMarketMakerActiveQuotes(optionAddress: string, underlyingAddress: string, fromUniqueEventId?: string, toUniqueEventId?: string, limit?: number, options?: any): AxiosPromise<Array<QuoteWithMetaDataDto>> {
            return localVarFp.getMarketMakerActiveQuotes(optionAddress, underlyingAddress, fromUniqueEventId, toUniqueEventId, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieves an overview of the market maker account.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMarketMakerOverview(options?: any): AxiosPromise<MakerOverviewDto> {
            return localVarFp.getMarketMakerOverview(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieves a list of market maker\'s trades
         * @param {string} includeTradeTypes 
         * @param {string} optionAddress 
         * @param {string} underlyingAddress 
         * @param {string} [fromUniqueEventId] 
         * @param {string} [toUniqueEventId] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMarketMakerTrades(includeTradeTypes: string, optionAddress: string, underlyingAddress: string, fromUniqueEventId?: string, toUniqueEventId?: string, limit?: number, options?: any): AxiosPromise<TradeDto> {
            return localVarFp.getMarketMakerTrades(includeTradeTypes, optionAddress, underlyingAddress, fromUniqueEventId, toUniqueEventId, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Fetch pending meta transactions which should be responded to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMetaTransactions(options?: any): AxiosPromise<Array<SignedMetaTransactionDto>> {
            return localVarFp.getMetaTransactions(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieves an option\'s details by its on-chain address. This will only * return option details if the option with that address has been created on-chain.
         * @param {string} optionAddress 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOption(optionAddress: string, options?: any): AxiosPromise<OptionDto> {
            return localVarFp.getOption(optionAddress, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieves a list of stats entries for given key
         * @param {string} key 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOptionStats(key: string, options?: any): AxiosPromise<Array<StatsDto>> {
            return localVarFp.getOptionStats(key, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary returns price registry events from Chainlink oracle where the event took place at 8am UTC
         * @param {string} underlyingAssetAddress 
         * @param {string} [fromUniqueEventId] 
         * @param {string} [toUniqueEventId] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPriceRegistryEvents(underlyingAssetAddress: string, fromUniqueEventId?: string, toUniqueEventId?: string, limit?: number, options?: any): AxiosPromise<PriceStoredDto> {
            return localVarFp.getPriceRegistryEvents(underlyingAssetAddress, fromUniqueEventId, toUniqueEventId, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Request a quote from market makers
         * @param {QuoteRequestDto} quoteRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQuote(quoteRequestDto: QuoteRequestDto, options?: any): AxiosPromise<QuoteDto> {
            return localVarFp.getQuote(quoteRequestDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieves the active quote requests that the authenticated market maker needs to respond to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQuoteRequests(options?: any): AxiosPromise<Array<MarketMakerQuoteRequestDto>> {
            return localVarFp.getQuoteRequests(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRandomQuote(options?: any): AxiosPromise<void> {
            return localVarFp.getRandomQuote(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieves a list of recent trades
         * @param {any} [underlyingAddress] 
         * @param {'CALL' | 'PUT'} [optionType] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecentTrades(underlyingAddress?: any, optionType?: 'CALL' | 'PUT', options?: any): AxiosPromise<Array<TradeDto>> {
            return localVarFp.getRecentTrades(underlyingAddress, optionType, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieves a trade with a given transaction hash
         * @param {string} txHash 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTrade(txHash: string, options?: any): AxiosPromise<TradeDto> {
            return localVarFp.getTrade(txHash, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieves a market maker\'s positions
         * @param {string} optionAddress 
         * @param {string} underlyingAddress 
         * @param {string} fromOption 
         * @param {string} toOption 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserPositions(optionAddress: string, underlyingAddress: string, fromOption: string, toOption: string, options?: any): AxiosPromise<Array<TradeDto>> {
            return localVarFp.getUserPositions(optionAddress, underlyingAddress, fromOption, toOption, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieves a list of a user\'s trades
         * @param {any} userAddress 
         * @param {'maker' | 'taker' | 'all'} [includeTradeTypes] Filter trades by trade type
         * @param {string} [optionAddress] 
         * @param {string} [underlyingAddress] 
         * @param {string} [fromUniqueEventId] 
         * @param {string} [toUniqueEventId] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserTrades(userAddress: any, includeTradeTypes?: 'maker' | 'taker' | 'all', optionAddress?: string, underlyingAddress?: string, fromUniqueEventId?: string, toUniqueEventId?: string, limit?: number, options?: any): AxiosPromise<Array<TradeDto>> {
            return localVarFp.getUserTrades(userAddress, includeTradeTypes, optionAddress, underlyingAddress, fromUniqueEventId, toUniqueEventId, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns a summary including assets, options, indicative quotes, prices, gas and config details.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getYield(options?: any): AxiosPromise<SummaryDto> {
            return localVarFp.getYield(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Batch respond to meta transaction requests
         * @param {Array<LastLookResponseWithOrderSignatureDto>} lastLookResponseWithOrderSignatureDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postMetaTransactionResponses(lastLookResponseWithOrderSignatureDto: Array<LastLookResponseWithOrderSignatureDto>, options?: any): AxiosPromise<Array<PostMetaTransactionResponseDto>> {
            return localVarFp.postMetaTransactionResponses(lastLookResponseWithOrderSignatureDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Posts quote responses
         * @param {Array<MarketMakerQuoteResponseDto>} marketMakerQuoteResponseDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postQuoteResponses(marketMakerQuoteResponseDto: Array<MarketMakerQuoteResponseDto>, options?: any): AxiosPromise<Array<QuoteResponseReplyDto>> {
            return localVarFp.postQuoteResponses(marketMakerQuoteResponseDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setInternalConfig(options?: any): AxiosPromise<void> {
            return localVarFp.setInternalConfig(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Sets the assets supported by the market maker
         * @param {SupportedUnderlyingAssetsDto} supportedUnderlyingAssetsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setMarketMakerAssets(supportedUnderlyingAssetsDto: SupportedUnderlyingAssetsDto, options?: any): AxiosPromise<MakerOverviewDto> {
            return localVarFp.setMarketMakerAssets(supportedUnderlyingAssetsDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Sets whether custom options are supported by the market maker
         * @param {SupportsCustomOptionsDto} supportsCustomOptionsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setSupportsCustomQuotes(supportsCustomOptionsDto: SupportsCustomOptionsDto, options?: any): AxiosPromise<MakerOverviewDto> {
            return localVarFp.setSupportsCustomQuotes(supportsCustomOptionsDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Submit a meta transaction
         * @param {SignedMetaTransactionDto} signedMetaTransactionDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitLastLookRequest(signedMetaTransactionDto: SignedMetaTransactionDto, options?: any): AxiosPromise<LastLookResponseDto> {
            return localVarFp.submitLastLookRequest(signedMetaTransactionDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for changeMarketMakerVisibility operation in DefaultApi.
 * @export
 * @interface DefaultApiChangeMarketMakerVisibilityRequest
 */
export interface DefaultApiChangeMarketMakerVisibilityRequest {
    /**
     * 
     * @type {SetMakerActiveDto}
     * @memberof DefaultApiChangeMarketMakerVisibility
     */
    readonly setMakerActiveDto: SetMakerActiveDto
}

/**
 * Request parameters for getMarketMakerActiveQuotes operation in DefaultApi.
 * @export
 * @interface DefaultApiGetMarketMakerActiveQuotesRequest
 */
export interface DefaultApiGetMarketMakerActiveQuotesRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiGetMarketMakerActiveQuotes
     */
    readonly optionAddress: string

    /**
     * 
     * @type {string}
     * @memberof DefaultApiGetMarketMakerActiveQuotes
     */
    readonly underlyingAddress: string

    /**
     * 
     * @type {string}
     * @memberof DefaultApiGetMarketMakerActiveQuotes
     */
    readonly fromUniqueEventId?: string

    /**
     * 
     * @type {string}
     * @memberof DefaultApiGetMarketMakerActiveQuotes
     */
    readonly toUniqueEventId?: string

    /**
     * 
     * @type {number}
     * @memberof DefaultApiGetMarketMakerActiveQuotes
     */
    readonly limit?: number
}

/**
 * Request parameters for getMarketMakerTrades operation in DefaultApi.
 * @export
 * @interface DefaultApiGetMarketMakerTradesRequest
 */
export interface DefaultApiGetMarketMakerTradesRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiGetMarketMakerTrades
     */
    readonly includeTradeTypes: string

    /**
     * 
     * @type {string}
     * @memberof DefaultApiGetMarketMakerTrades
     */
    readonly optionAddress: string

    /**
     * 
     * @type {string}
     * @memberof DefaultApiGetMarketMakerTrades
     */
    readonly underlyingAddress: string

    /**
     * 
     * @type {string}
     * @memberof DefaultApiGetMarketMakerTrades
     */
    readonly fromUniqueEventId?: string

    /**
     * 
     * @type {string}
     * @memberof DefaultApiGetMarketMakerTrades
     */
    readonly toUniqueEventId?: string

    /**
     * 
     * @type {number}
     * @memberof DefaultApiGetMarketMakerTrades
     */
    readonly limit?: number
}

/**
 * Request parameters for getOption operation in DefaultApi.
 * @export
 * @interface DefaultApiGetOptionRequest
 */
export interface DefaultApiGetOptionRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiGetOption
     */
    readonly optionAddress: string
}

/**
 * Request parameters for getOptionStats operation in DefaultApi.
 * @export
 * @interface DefaultApiGetOptionStatsRequest
 */
export interface DefaultApiGetOptionStatsRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiGetOptionStats
     */
    readonly key: string
}

/**
 * Request parameters for getPriceRegistryEvents operation in DefaultApi.
 * @export
 * @interface DefaultApiGetPriceRegistryEventsRequest
 */
export interface DefaultApiGetPriceRegistryEventsRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiGetPriceRegistryEvents
     */
    readonly underlyingAssetAddress: string

    /**
     * 
     * @type {string}
     * @memberof DefaultApiGetPriceRegistryEvents
     */
    readonly fromUniqueEventId?: string

    /**
     * 
     * @type {string}
     * @memberof DefaultApiGetPriceRegistryEvents
     */
    readonly toUniqueEventId?: string

    /**
     * 
     * @type {number}
     * @memberof DefaultApiGetPriceRegistryEvents
     */
    readonly limit?: number
}

/**
 * Request parameters for getQuote operation in DefaultApi.
 * @export
 * @interface DefaultApiGetQuoteRequest
 */
export interface DefaultApiGetQuoteRequest {
    /**
     * 
     * @type {QuoteRequestDto}
     * @memberof DefaultApiGetQuote
     */
    readonly quoteRequestDto: QuoteRequestDto
}

/**
 * Request parameters for getRecentTrades operation in DefaultApi.
 * @export
 * @interface DefaultApiGetRecentTradesRequest
 */
export interface DefaultApiGetRecentTradesRequest {
    /**
     * 
     * @type {any}
     * @memberof DefaultApiGetRecentTrades
     */
    readonly underlyingAddress?: any

    /**
     * 
     * @type {'CALL' | 'PUT'}
     * @memberof DefaultApiGetRecentTrades
     */
    readonly optionType?: 'CALL' | 'PUT'
}

/**
 * Request parameters for getTrade operation in DefaultApi.
 * @export
 * @interface DefaultApiGetTradeRequest
 */
export interface DefaultApiGetTradeRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiGetTrade
     */
    readonly txHash: string
}

/**
 * Request parameters for getUserPositions operation in DefaultApi.
 * @export
 * @interface DefaultApiGetUserPositionsRequest
 */
export interface DefaultApiGetUserPositionsRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiGetUserPositions
     */
    readonly optionAddress: string

    /**
     * 
     * @type {string}
     * @memberof DefaultApiGetUserPositions
     */
    readonly underlyingAddress: string

    /**
     * 
     * @type {string}
     * @memberof DefaultApiGetUserPositions
     */
    readonly fromOption: string

    /**
     * 
     * @type {string}
     * @memberof DefaultApiGetUserPositions
     */
    readonly toOption: string
}

/**
 * Request parameters for getUserTrades operation in DefaultApi.
 * @export
 * @interface DefaultApiGetUserTradesRequest
 */
export interface DefaultApiGetUserTradesRequest {
    /**
     * 
     * @type {any}
     * @memberof DefaultApiGetUserTrades
     */
    readonly userAddress: any

    /**
     * Filter trades by trade type
     * @type {'maker' | 'taker' | 'all'}
     * @memberof DefaultApiGetUserTrades
     */
    readonly includeTradeTypes?: 'maker' | 'taker' | 'all'

    /**
     * 
     * @type {string}
     * @memberof DefaultApiGetUserTrades
     */
    readonly optionAddress?: string

    /**
     * 
     * @type {string}
     * @memberof DefaultApiGetUserTrades
     */
    readonly underlyingAddress?: string

    /**
     * 
     * @type {string}
     * @memberof DefaultApiGetUserTrades
     */
    readonly fromUniqueEventId?: string

    /**
     * 
     * @type {string}
     * @memberof DefaultApiGetUserTrades
     */
    readonly toUniqueEventId?: string

    /**
     * 
     * @type {number}
     * @memberof DefaultApiGetUserTrades
     */
    readonly limit?: number
}

/**
 * Request parameters for postMetaTransactionResponses operation in DefaultApi.
 * @export
 * @interface DefaultApiPostMetaTransactionResponsesRequest
 */
export interface DefaultApiPostMetaTransactionResponsesRequest {
    /**
     * 
     * @type {Array<LastLookResponseWithOrderSignatureDto>}
     * @memberof DefaultApiPostMetaTransactionResponses
     */
    readonly lastLookResponseWithOrderSignatureDto: Array<LastLookResponseWithOrderSignatureDto>
}

/**
 * Request parameters for postQuoteResponses operation in DefaultApi.
 * @export
 * @interface DefaultApiPostQuoteResponsesRequest
 */
export interface DefaultApiPostQuoteResponsesRequest {
    /**
     * 
     * @type {Array<MarketMakerQuoteResponseDto>}
     * @memberof DefaultApiPostQuoteResponses
     */
    readonly marketMakerQuoteResponseDto: Array<MarketMakerQuoteResponseDto>
}

/**
 * Request parameters for setMarketMakerAssets operation in DefaultApi.
 * @export
 * @interface DefaultApiSetMarketMakerAssetsRequest
 */
export interface DefaultApiSetMarketMakerAssetsRequest {
    /**
     * 
     * @type {SupportedUnderlyingAssetsDto}
     * @memberof DefaultApiSetMarketMakerAssets
     */
    readonly supportedUnderlyingAssetsDto: SupportedUnderlyingAssetsDto
}

/**
 * Request parameters for setSupportsCustomQuotes operation in DefaultApi.
 * @export
 * @interface DefaultApiSetSupportsCustomQuotesRequest
 */
export interface DefaultApiSetSupportsCustomQuotesRequest {
    /**
     * 
     * @type {SupportsCustomOptionsDto}
     * @memberof DefaultApiSetSupportsCustomQuotes
     */
    readonly supportsCustomOptionsDto: SupportsCustomOptionsDto
}

/**
 * Request parameters for submitLastLookRequest operation in DefaultApi.
 * @export
 * @interface DefaultApiSubmitLastLookRequestRequest
 */
export interface DefaultApiSubmitLastLookRequestRequest {
    /**
     * 
     * @type {SignedMetaTransactionDto}
     * @memberof DefaultApiSubmitLastLookRequest
     */
    readonly signedMetaTransactionDto: SignedMetaTransactionDto
}

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public _function(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration)._function(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Controls whether the market maker will be asked to provide quotes
     * @param {DefaultApiChangeMarketMakerVisibilityRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public changeMarketMakerVisibility(requestParameters: DefaultApiChangeMarketMakerVisibilityRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).changeMarketMakerVisibility(requestParameters.setMakerActiveDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieves a list of all active options (non-expired)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getAllActiveOptions(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getAllActiveOptions(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieves a list of all supported assets and their price
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getAllAssets(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getAllAssets(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets prices of all assets
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getAllPrices(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getAllPrices(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieves the configuration details of the network
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getConfig(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getConfig(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets the latest gas details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getGasDetails(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getGasDetails(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get indicative quotes of assets
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getIndicativeQuotes(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getIndicativeQuotes(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getInternalConfig(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getInternalConfig(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieves a list of market maker\'s active quotes. Active means not filled, not cancelled and not expired.
     * @param {DefaultApiGetMarketMakerActiveQuotesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getMarketMakerActiveQuotes(requestParameters: DefaultApiGetMarketMakerActiveQuotesRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getMarketMakerActiveQuotes(requestParameters.optionAddress, requestParameters.underlyingAddress, requestParameters.fromUniqueEventId, requestParameters.toUniqueEventId, requestParameters.limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieves an overview of the market maker account.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getMarketMakerOverview(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getMarketMakerOverview(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieves a list of market maker\'s trades
     * @param {DefaultApiGetMarketMakerTradesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getMarketMakerTrades(requestParameters: DefaultApiGetMarketMakerTradesRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getMarketMakerTrades(requestParameters.includeTradeTypes, requestParameters.optionAddress, requestParameters.underlyingAddress, requestParameters.fromUniqueEventId, requestParameters.toUniqueEventId, requestParameters.limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Fetch pending meta transactions which should be responded to
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getMetaTransactions(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getMetaTransactions(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieves an option\'s details by its on-chain address. This will only * return option details if the option with that address has been created on-chain.
     * @param {DefaultApiGetOptionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getOption(requestParameters: DefaultApiGetOptionRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getOption(requestParameters.optionAddress, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieves a list of stats entries for given key
     * @param {DefaultApiGetOptionStatsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getOptionStats(requestParameters: DefaultApiGetOptionStatsRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getOptionStats(requestParameters.key, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary returns price registry events from Chainlink oracle where the event took place at 8am UTC
     * @param {DefaultApiGetPriceRegistryEventsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getPriceRegistryEvents(requestParameters: DefaultApiGetPriceRegistryEventsRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getPriceRegistryEvents(requestParameters.underlyingAssetAddress, requestParameters.fromUniqueEventId, requestParameters.toUniqueEventId, requestParameters.limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Request a quote from market makers
     * @param {DefaultApiGetQuoteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getQuote(requestParameters: DefaultApiGetQuoteRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getQuote(requestParameters.quoteRequestDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieves the active quote requests that the authenticated market maker needs to respond to.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getQuoteRequests(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getQuoteRequests(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getRandomQuote(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getRandomQuote(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieves a list of recent trades
     * @param {DefaultApiGetRecentTradesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getRecentTrades(requestParameters: DefaultApiGetRecentTradesRequest = {}, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getRecentTrades(requestParameters.underlyingAddress, requestParameters.optionType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieves a trade with a given transaction hash
     * @param {DefaultApiGetTradeRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getTrade(requestParameters: DefaultApiGetTradeRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getTrade(requestParameters.txHash, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieves a market maker\'s positions
     * @param {DefaultApiGetUserPositionsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getUserPositions(requestParameters: DefaultApiGetUserPositionsRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getUserPositions(requestParameters.optionAddress, requestParameters.underlyingAddress, requestParameters.fromOption, requestParameters.toOption, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieves a list of a user\'s trades
     * @param {DefaultApiGetUserTradesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getUserTrades(requestParameters: DefaultApiGetUserTradesRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getUserTrades(requestParameters.userAddress, requestParameters.includeTradeTypes, requestParameters.optionAddress, requestParameters.underlyingAddress, requestParameters.fromUniqueEventId, requestParameters.toUniqueEventId, requestParameters.limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns a summary including assets, options, indicative quotes, prices, gas and config details.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getYield(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getYield(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Batch respond to meta transaction requests
     * @param {DefaultApiPostMetaTransactionResponsesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public postMetaTransactionResponses(requestParameters: DefaultApiPostMetaTransactionResponsesRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).postMetaTransactionResponses(requestParameters.lastLookResponseWithOrderSignatureDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Posts quote responses
     * @param {DefaultApiPostQuoteResponsesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public postQuoteResponses(requestParameters: DefaultApiPostQuoteResponsesRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).postQuoteResponses(requestParameters.marketMakerQuoteResponseDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public setInternalConfig(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).setInternalConfig(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Sets the assets supported by the market maker
     * @param {DefaultApiSetMarketMakerAssetsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public setMarketMakerAssets(requestParameters: DefaultApiSetMarketMakerAssetsRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).setMarketMakerAssets(requestParameters.supportedUnderlyingAssetsDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Sets whether custom options are supported by the market maker
     * @param {DefaultApiSetSupportsCustomQuotesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public setSupportsCustomQuotes(requestParameters: DefaultApiSetSupportsCustomQuotesRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).setSupportsCustomQuotes(requestParameters.supportsCustomOptionsDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Submit a meta transaction
     * @param {DefaultApiSubmitLastLookRequestRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public submitLastLookRequest(requestParameters: DefaultApiSubmitLastLookRequestRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).submitLastLookRequest(requestParameters.signedMetaTransactionDto, options).then((request) => request(this.axios, this.basePath));
    }
}
